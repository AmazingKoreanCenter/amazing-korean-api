# PATCH REQUEST — FRONTEND Phase 4-1 (Study List GET)

**ROLE**:
- 당신은 **Amazing Korean API의 프론트엔드 전담 AI 에이전트**입니다.
- **Tech Stack**: React (Vite), TypeScript, Tailwind CSS, Shadcn/ui, TanStack Query.
- **AMK_API_MASTER.md**의 Phase 4-1 스펙과 사용자가 제공한 **Zod Schema**를 엄격히 준수합니다.

**OBJECTIVE**:
- **학습 문제 목록 페이지 (`StudyListPage`)**를 구현합니다.
- 사용자는 학습 프로그램(`study_program`) 별로 필터링하여 문제 목록을 볼 수 있어야 합니다.
- **HomePage**에 '학습하기(Study)' 메뉴 또는 버튼을 추가하여 이 페이지로의 진입점을 만듭니다.

**CONTEXT (Spec & Types)**:
1.  **Endpoint**: `GET /studies`
2.  **Params**: `page` (def: 1), `per_page` (def: 10), `program` (Optional Enum), `sort` (Optional).
3.  **State Axis**:
    - **Auth**: `pass`(로그인) 또는 `stop`(비로그인) 모두 접근 가능 (Public View).
    - **Data**: `empty`인 경우 "등록된 문제가 없습니다" 표시.
4.  **Provided Zod Schemas (Contract)**:
    - 아래 코드를 `src/types.ts`에 정확히 복사하여 사용할 것.

```typescript
import { z } from "zod";

export const studyProgramSchema = z.enum([
  "basic_pronunciation",
  "basic_word",
  "basic_900",
  "topik_read",
  "topik_listen",
  "topik_write",
  "tbc",
]);
export type StudyProgram = z.infer<typeof studyProgramSchema>;

export const studyTaskKindSchema = z.enum(["choice", "typing", "voice"]);
export type StudyTaskKind = z.infer<typeof studyTaskKindSchema>;

export const studyListReqSchema = z.object({
  page: z.number().int().min(1).optional(),
  per_page: z.number().int().min(1).max(100).optional(),
  program: z.string().optional(),
  sort: z.string().optional(),
});
export type StudyListReq = z.infer<typeof studyListReqSchema>;

export const studyListItemSchema = z.object({
  study_id: z.number().int(),
  study_idx: z.string(),
  study_program: studyProgramSchema,
  title: z.string().optional(),
  subtitle: z.string().optional(),
  created_at: z.string().datetime(),
});
export type StudyListItem = z.infer<typeof studyListItemSchema>;

export const studyListMetaSchema = z.object({
  page: z.number().int(),
  per_page: z.number().int(),
  total: z.number().int(),
  total_pages: z.number().int(),
});
export type StudyListMeta = z.infer<typeof studyListMetaSchema>;

export const studyListResSchema = z.object({
  data: z.array(studyListItemSchema),
  meta: studyListMetaSchema,
});
export type StudyListRes = z.infer<typeof studyListResSchema>;

// ... (StudyTaskDetail, SubmitAnswer 등 나머지 스키마도 추후 사용을 위해 함께 types.ts에 포함할 것)
```

**MCP ACTIONS (필수 수행)**:
작업 시작 전 다음 파일들을 읽고 컨텍스트를 확보하십시오.
1.  **Read Types**: `src/types.ts` (기존 내용 확인 후 위 스키마 추가 병합).
2.  **Read Client**: `src/api/client.ts` (API 호출 방식 확인).
3.  **Read Router**: `src/routes.tsx` (라우팅 등록 위치 확인).
4.  **Read Home**: `src/category/home/page/HomePage.tsx` (버튼 추가 위치 파악).

**IMPLEMENTATION STEPS**:

1.  **Step 1. Type Definition (`src/types.ts`)**:
    - 위 **CONTEXT**에 제공된 모든 Zod 스키마와 Type을 `src/types.ts`에 추가하십시오. (이미 있다면 덮어쓰거나 최신화).

2.  **Step 2. API Function (`src/api/study.ts`)**:
    - `getStudyList(params: StudyListReq)` 함수를 작성하십시오.
    - `axios` paramsSerializer 등을 활용하지 않는다면, `program`이 `undefined`일 때 query param에서 제외되도록 처리하십시오.

3.  **Step 3. Custom Hook (`src/category/study/hook/useStudyList.ts`)**:
    - `useQuery`를 사용하여 목록을 가져오는 훅을 작성하십시오.
    - **Query Key**: `['studies', { page, program, sort }]`.
    - **KeepPreviousData**: 페이지네이션 시 깜빡임 방지를 위해 `placeholderData: keepPreviousData` 옵션을 사용하십시오.

4.  **Step 4. UI Page (`src/category/study/page/StudyListPage.tsx`)**:
    - **Layout**: 상단에 `Program` 필터(Tabs 또는 Select)를 배치하십시오.
    - **List**: `data.map`을 통해 문제 목록을 카드(Card) 형태로 렌더링하십시오.
    - **Empty State**: 데이터가 없을 경우 안내 메시지를 표시하십시오.
    - **Navigation**: 리스트 아이템 클릭 시 `/studies/:id`로 이동하도록 `Link`를 설정하십시오 (상세 페이지는 추후 구현).

5.  **Step 5. Entry Point (`src/category/home/page/HomePage.tsx`)**:
    - 홈 화면의 적절한 위치(예: Quick Menu 또는 Grid)에 **"학습하기(Study)"** 버튼을 추가하십시오.
    - 클릭 시 `/studies`로 이동해야 합니다.

6.  **Step 6. Route Registration (`src/routes.tsx`)**:
    - `/studies` 경로에 `StudyListPage`를 연결하십시오.

**PATCH RULES (Iron Rules)**:
1.  **Strict Type Safety**: `any` 사용 금지. 제공된 `StudyListRes`, `StudyListItem` 타입을 사용하십시오.
2.  **UI/UX**: 목록 로딩 중에는 `Skeleton` UI를 사용하여 부드러운 경험을 제공하십시오.
3.  **Separation**: 비즈니스 로직(데이터 fetching)은 Hook으로 분리하고, View는 오직 렌더링만 담당하게 하십시오.