# PATCH REQUEST — FRONTEND Phase 1-4 Axios Interceptor (Silent Refresh)

**ROLE**:
- Frontend Developer (Axios, TypeScript, Zustand).

**OBJECTIVE**:
- `src/api/client.ts`에 **Response Interceptor**를 구현하여, Access Token 만료(401) 시 자동으로 쿠키 기반의 재발급을 수행하고 요청을 재시도(Retry)하게 하시오.

**MCP ACTIONS**:
1.  **Read Client**: `src/api/client.ts` 확인.
2.  **Read Store**: `src/hooks/use_auth_store.ts`에서 `logout` 및 `setAccessToken`(또는 `login`) 액션 확인.

**TECHNICAL CONSTRAINTS (Strict)**:
1.  **Cookie Handling**:
    - Axios 인스턴스 생성 시 `withCredentials: true` 설정 필수. (브라우저가 리프레시 토큰 쿠키를 자동으로 전송하기 위함)
2.  **Endpoint**:
    - URL: `POST /auth/refresh`
    - Body: Empty (쿠키에 토큰이 있음)
    - Response: `LoginRes` JSON (새로운 `access_token` 포함)
3.  **Rotation Logic**:
    - 재발급 성공 시, 백엔드가 `Set-Cookie` 헤더로 새로운 리프레시 토큰을 구워줍니다. 프론트엔드는 이를 따로 처리할 필요가 없습니다 (브라우저 자동 처리).

**IMPLEMENTATION FLOW**:
1.  **Intercept**: 응답 에러가 `401 Unauthorized`이고, `!originalRequest._retry`일 때 진입.
2.  **Flag**: `originalRequest._retry = true` 설정 (무한 루프 방지).
3.  **Refresh Request**: `client.post('/auth/refresh')` 호출.
4.  **Success Handling**:
    - 응답 데이터에서 `access.access_token` 추출.
    - **Header Update**: `client.defaults.headers.common['Authorization']` 및 `originalRequest.headers['Authorization']` 업데이트.
    - **Store Update**: `useAuthStore.getState().login(...)` 또는 토큰 갱신 액션을 호출하여 메모리 상의 토큰 정보 동기화.
    - **Retry**: `return client(originalRequest)` 실행.
5.  **Failure Handling**:
    - Refresh API조차 실패(401/403/409)하면 세션이 완전히 만료된 것임.
    - `useAuthStore.getState().logout()` 실행.
    - `window.location.href = '/login'`로 강제 이동.

**FILE PATCHES**:
// src/api/client.ts

**CODE PATTERN**:
```typescript
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      try {
        const { data } = await api.post('/auth/refresh');
        // 토큰 포맷: "Bearer " + token
        const newToken = `Bearer ${data.access.access_token}`;
        
        // 헤더 갱신
        api.defaults.headers.common['Authorization'] = newToken;
        originalRequest.headers['Authorization'] = newToken;
        
        // 스토어 동기화 (선택적이지만 권장)
        useAuthStore.getState().login(data);

        return api(originalRequest);
      } catch (refreshError) {
        useAuthStore.getState().logout();
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }
    return Promise.reject(error);
  }
);
```