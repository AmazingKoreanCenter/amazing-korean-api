# 🛠️ Issue Log: Phase 2-4 (Update Settings UI) Implementation

## 📋 개요
- **작업**: 사용자 설정 수정 페이지(`/settings`)를 `React Hook Form` 기반의 수정 가능한 폼으로 전환하고 `POST` 요청 구현.
- **기간**: 2026.01.13
- **주요 성과**:
  - `React Hook Form`의 `isDirty` 상태를 활용한 저장 버튼 활성화/비활성화 UX 구현.
  - 백엔드 DB 스키마(`users_setting`)와 프론트엔드 UI 필드 동기화 완료.

---

## 🚨 Critical Issues & AI Hallucinations (중대 오류 및 환각)

### 1. 타입 환각 및 스키마 불일치 (Type Hallucination) 🛑
- **현상**:
  - `settings_page.tsx`에서 저장 버튼을 눌러도 네트워크 탭에서는 `200 OK`가 뜨지만, **실제 DB에는 값이 저장되지 않음.**
- **원인 (AI Error)**:
  - **AI의 치명적 실수**: 기존 `types.ts`에 이미 정의된 **`SettingsUpdateReq`**(`user_set_language` 등)를 확인하지 않음.
  - **환각 코드 생성**: 대신 **`UpdateSettingReq`**라는 가상의 타입을 임의로 생성하고, 백엔드가 알 수 없는 필드명(`is_email_marketing_agreed`, `theme` 등)을 사용하여 코드를 작성함.
  - 결과적으로 프론트엔드는 백엔드가 무시하는 엉뚱한 키 값들만 전송하고 있었음.
- **해결**:
  - **SSOT(Single Source of Truth) 재확립**: `types.ts`의 `SettingsUpdateReq`를 유일한 기준점으로 확정.
  - **전면 리팩토링**: `user_api.ts`, `use_update_settings.ts`, `settings_page.tsx`의 모든 타입을 실제 DB 컬럼명(`user_set_...`) 기반으로 수정.
  - **불필요 코드 삭제**: 환각으로 만들어진 `UpdateSettingReq` 및 관련 스키마 제거.

### 2. UI 필드 누락 및 잘못된 매핑
- **현상**:
  - 백엔드 DB에는 `user_set_note_push`(앱 푸시 알림) 컬럼이 존재하나, 초기 UI 구현에서 이를 누락함.
  - 반대로 DB에 없는 `theme` 설정을 API 전송 데이터에 포함시키려 함.
- **해결**:
  - **필드 추가**: `settings_page.tsx`에 "앱 푸시 알림"용 `Switch` 컴포넌트 추가 및 `user_set_note_push` 바인딩.
  - **필드 제외**: `theme`은 현재 DB 스키마에 없으므로 API 전송 페이로드(`data`)에서 제외하고, 추후 로컬 상태 관리로 분리하기로 결정.

---

## 🐛 일반 발생 이슈 (General Troubleshooting)

### 1. 폼 초기값 바인딩 시점 (Reset Timing)
- **이슈**: 페이지 진입 시 데이터(`useQuery`)를 가져오는 동안 폼이 `defaultValues`로 렌더링되었다가, 데이터가 로드된 후에도 값이 갱신되지 않는 문제.
- **해결**:
  - `useEffect`를 사용하여 `settings` 데이터가 로드되는 시점(`if (settings)`)에 `form.reset(settings)`를 호출, 서버 데이터를 폼에 강제 주입(Pre-fill)함.

### 2. 버튼 활성화 로직 (UX)
- **이슈**: 사용자가 아무것도 변경하지 않았는데도 [저장] 버튼이 활성화되어 있어 불필요한 API 요청 유발 가능성.
- **해결**:
  - `form.formState.isDirty` 속성을 사용하여, **초기값과 다른 부분이 하나라도 있을 때만** 버튼이 활성화되도록 처리.

---

## 💡 Key Takeaways (교훈)

1.  **Check Existing Types First (기존 타입 확인 필수)**:
    - AI나 개발자나 코드를 작성하기 전에 반드시 `types.ts`나 `Swagger/DTO`를 열어보고 **이미 정의된 규격**이 있는지 확인해야 한다. 추측으로 변수명을 지으면 100% 통신 오류가 발생한다.
2.  **Mapping Integrity (DTO 매핑)**:
    - 프론트엔드 Form의 `name` 속성은 백엔드 DTO의 `field` 명과 **반드시 1:1로 일치**해야 한다. (`camelCase` vs `snake_case` 주의).
3.  **Clean Up Hallucinations**:
    - 잘못된 타입 정의(`UpdateSettingReq`)가 발견되면, 헷갈리지 않게 즉시 코드베이스에서 **삭제**해야 한다.