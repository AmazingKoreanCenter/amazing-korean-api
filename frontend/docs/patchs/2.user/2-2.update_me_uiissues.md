# 🛠️ Issue Log: Phase 2-2 (Update User UI) Implementation

## 📋 개요
- **작업**: 사용자 정보 수정 페이지(`/user/edit`) 구현 및 데이터 동기화 로직 적용.
- **기간**: 2026.01.13
- **주요 성과**:
  - **Form Pre-fill**: React Hook Form의 `reset()`을 활용하여 기존 사용자 정보를 수정 폼에 자동 입력하는 UX 구현.
  - **Data Consistency**: 수정 성공 즉시 `invalidateQueries`를 호출하여, 내 정보 페이지(`/user/me`) 진입 시 최신 데이터가 표시되도록 보장.
  - **Schema Alignment**: 백엔드 스펙과 프론트엔드 입력 필드 간의 불일치를 식별하고 조정.

---

## 🐛 발생 이슈 및 해결 (Troubleshooting)

### 1. Schema Mismatch (`bio` Field)
- **현상**: 기획 단계에서는 자기소개(`bio`) 필드가 포함되었으나, 실제 백엔드 DB 및 DTO에는 해당 필드가 존재하지 않음.
- **영향**: 프론트엔드에서 `bio` 데이터를 전송해도 백엔드에서 무시되거나(Silent Fail), 400 Bad Request가 발생할 가능성 있음.
- **조치 (Spec Down)**:
  - 현재 백엔드 스펙에 맞춰 `UpdateUserReq` 타입과 Zod 스키마에서 `bio` 필드를 제거.
  - 해당 기능은 추후 백엔드 DB 마이그레이션이 선행된 후 구현하기로 하고 **Upgrade Plan (Phase 2-2+)**으로 이관.

### 2. 폼 초기값 바인딩 시점 (Pre-fill Timing)
- **이슈**: `useUserMe` 훅을 통해 데이터를 가져오는 비동기 시점과 컴포넌트 렌더링 시점의 차이로 인해, 초기 폼이 비어있거나 `undefined`가 입력되는 현상.
- **해결**:
  - `useEffect`를 사용하여 `userData`가 로드되는 시점에 `form.reset(userData)`를 호출하여 값을 주입.
  - 데이터 로딩 중에는 `<Skeleton>` UI를 표시하여 빈 폼이 노출되는 것을 방지.

### 3. 수정 후 데이터 갱신 (Stale Data)
- **이슈**: 정보 수정(`POST /users/me`) 성공 후 `/user/me`로 이동했을 때, 브라우저가 캐싱된 기존 데이터를 보여주어 수정 사항이 반영되지 않은 것처럼 보임.
- **해결**:
  - `useMutation`의 `onSuccess` 콜백에서 `queryClient.invalidateQueries({ queryKey: ['user', 'me'] })`를 호출.
  - 이를 통해 `/user/me` 쿼리를 '만료(Stale)' 처리하고, 다음 조회 시 강제로 서버에서 최신 데이터를 가져오게 함.

---

## 💡 Key Takeaways (교훈)
1.  **Check Backward Compatibility**: 프론트엔드 UI를 기획할 때는 반드시 현재 배포된 백엔드 API 명세(Swagger/DTO)를 먼저 확인해야 한다. "당연히 있겠지"라고 가정하면 나중에 걷어내는 비용이 든다.
2.  **Sync State Manually**: 서버 상태(Server State)는 로컬 상태와 달리 즉각 반영되지 않으므로, 수정(Mutation) 후에는 반드시 '무효화(Invalidation)' 전략을 세워야 한다.