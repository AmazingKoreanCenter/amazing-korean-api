# UPGRADE PROPOSAL — Phase 3-4 (Video Progress POST)

**Date**: 2026-01-16
**Author**: Amazing Korean Frontend Agent
**Scope**: Video Progress Saving Logic & Data Integrity

## 1. Overview
현재 Phase 3-4 구현은 `onPause`와 `onEnded` 이벤트에 의존하여 마지막 시점의 진도율을 저장합니다.
하지만 단순한 위치 저장을 넘어, **"사용자가 실제로 얼마나 충실히 학습했는가?"** 를 판단하고, **네트워크 불안정 상황**에서도 학습 기록을 유실하지 않기 위한 고도화가 필요합니다.

## 2. Proposed Features

### 🎯 Priority A: Precision Logging (1~100 Int Support)
- **Problem**: 현재는 일시정지 시점의 퍼센트만 저장하므로, 영상을 듬성듬성 스킵하며 봐도 `onEnded` 시점에는 100%로 저장될 위험이 있음.
- **Requirement**: "1부터 100까지 정수(Int) 값"을 정밀하게 처리.
- **Solution**:
    - **Interval Tracking**: 영상 재생 중 **10초(또는 10%) 주기**로 현재 진도율을 백그라운드에서 저장 (`onProgress` 이벤트 활용).
    - **Validation Logic**: 클라이언트에서 `Math.round()`를 사용하여 소수점을 날리고 명확한 **1~100 사이의 정수(Int)** 만 전송.
    - **Backend Impact**: DB의 `video_progress_log` 컬럼에 시계열 데이터가 쌓이진 않더라도(현재 구조상), `last_watched_at`이 주기적으로 갱신되어 "방금까지 보고 있었다"는 **Liveness**를 보장함.

### 📡 Priority B: Offline Sync (Network Resilience)
- **Problem**: 지하철이나 엘리베이터 등 네트워크가 끊긴 상태(Offline)에서 영상을 보다가 종료하면 학습 기록이 날아감.
- **Solution**: **`localStorage` Queue Pattern** 도입.
    1.  API 요청 실패 시, 해당 진도율 데이터(`{videoId: 1, progress: 55}`)를 로컬 스토리지에 저장.
    2.  네트워크 복구(`window.addEventListener('online')`) 또는 다음번 앱 실행 시, 저장된 큐를 서버로 **재전송(Retry)**.

### ⏱️ Priority C: Actual Watch Time (Learning Integrity)
- **Problem**: 1시간짜리 영상을 2배속으로 보거나 스크러버(Bar)를 밀어서 1분 만에 끝내도 `100%` 완료로 인정됨.
- **Solution**:
    - **`actual_watch_seconds`** 추적.
    - `last_position_sec` (위치)와 별개로, 타이머를 돌려 사용자가 실제로 화면을 켜두고 재생한 누적 시간을 계산하여 함께 전송.
    - 예: "진도율은 100%인데 시청 시간은 3분이다" → 어뷰징(Abusing) 탐지 가능.

### ⚡ Priority D: Beacon API (Reliable Exit Logging)
- **Problem**: 사용자가 브라우저 탭을 갑자기 닫거나 새로고침할 때, `useEffect cleanup`이나 `onUnmount`의 비동기 요청(Axios)은 브라우저에 의해 취소(Cancel)될 확률이 높음.
- **Solution**: **`navigator.sendBeacon`** 사용.
    - 탭이 닫히는 급박한 순간에도 브라우저가 백그라운드에서 전송을 보장하는 API로 교체.
    - `useVideoProgress` 훅의 `saveOnExit` 로직에 적용.

## 3. Implementation Logic Example (Priority A)

```typescript
// interval logging concept
useEffect(() => {
  const interval = setInterval(() => {
    if (!player.isPlaying) return;
    
    const currentPercent = Math.floor((player.currentTime / player.duration) * 100);
    
    // 1% 이상 변화가 있고, 1~100 범위일 때만 저장 시도 (부하 조절)
    if (currentPercent > lastSavedPercent && currentPercent <= 100) {
      saveProgress({ progress_rate: currentPercent });
      setLastSavedPercent(currentPercent);
    }
  }, 10000); // 10초마다 체크

  return () => clearInterval(interval);
}, [player.isPlaying]);
```

## 4. Conclusion
사용자의 요청인 **"1~100 정수 저장"** 을 확실히 지원하기 위해, 단순 이벤트 트리거 방식을 넘어 **주기적 동기화(Interval Sync)** 방식의 도입을 권장합니다. 이는 추후 학습 분석(Analytics)의 정확도를 크게 높여줄 것입니다.