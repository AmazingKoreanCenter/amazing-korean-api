# === Amazing Korean Support Bundle ===

## rust/cargo version
rustc 1.80.0 (051478957 2024-07-21)
cargo 1.80.0 (376290515 2024-07-16)

## cargo tree (features)
error: failed to parse manifest at `/home/kkryo/dev/amazing-korean-api/Cargo.toml`

Caused by:
  feature `edition2024` is required

  The package requires the Cargo feature called `edition2024`, but that feature is not stabilized in this version of Cargo (1.80.0 (376290515 2024-07-16)).
  Consider trying a newer version of Cargo (this may require the nightly release).
  See https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#edition-2024 for more information about the status of this feature.

## project tree (L3)
target/.rustc_info.json
target/debug/.cargo-lock
target/debug/amazing-korean-api
target/debug/amazing-korean-api.d
target/.future-incompat-report.json
target/CACHEDIR.TAG
rust-toolchain.toml
.vscode/launch.json
.env
src/error.rs
src/api/mod.rs
src/docs.rs
src/main.rs
src/state.rs
Cargo.lock
Cargo.toml
.git/config
.git/description
.git/info/exclude
.git/HEAD
.git/hooks/pre-commit.sample
.git/hooks/pre-applypatch.sample
.git/hooks/pre-merge-commit.sample
.git/hooks/applypatch-msg.sample
.git/hooks/pre-receive.sample
.git/hooks/sendemail-validate.sample
.git/hooks/pre-push.sample
.git/hooks/prepare-commit-msg.sample
.git/hooks/pre-rebase.sample
.git/hooks/fsmonitor-watchman.sample
.git/hooks/commit-msg.sample
.git/hooks/update.sample
.git/hooks/push-to-checkout.sample
.git/hooks/post-update.sample
scripts/mk-support-bundle.sh
support-bundle.txt
.gitignore
migrations/20250812052946_core_user_course_pay.sql
migrations/20250812043521_init.sql

## Cargo.toml
[package]
name = "amazing-korean-api"
version = "0.1.0"
edition = "2024"

[dependencies]
axum = { version = "0.8.4", features =  ["macros", "tokio", "http1", "http2"] }
tokio = { version = "1", features = ["rt-multi-thread", "macros", "net", "signal"] }
tracing = "0.1"
tracing-subscriber = "0.3"
dotenvy = "0.15"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
sqlx = { version = "0.7", features = ["runtime-tokio", "postgres", "macros", "uuid", "chrono"] }
uuid = { version = "1", features = ["v4"] }
anyhow = "1"
validator = { version = "0.20.0", features = ["derive"] }
thiserror = "2.0.14"
tower = "0.5"
hyper = "1"
http = "1"
tower-http = "0.6"
argon2 = "0.5"
password-hash = "0.5"
rand_core = "0.6"
jsonwebtoken = "9"
time = "0.3"
chrono = { version = "0.4", features = ["serde"] }
utoipa = { version = "5.4.0", features = ["chrono"] }
utoipa-swagger-ui = { version = "9.0.2", features = ["axum"] }

## rust-toolchain.toml
[toolchain]
channel = "1.80.0"
components = ["rustfmt", "clippy"]

## .env (masked)
DATABASE_URL=<REDACTED>
JWT_SECRET=<REDACTED>
JWT_EXPIRE_HOURS=24
BIND_ADDR=0.0.0.0:3000
ENABLE_DOCS=1
# ë¬¸ì„œë§Œ ë¹¨ë¦¬ ë³¼ ë•Œ = 1, ì‹¤ì œ DB ì—°ê²°ê¹Œì§€ í™•ì¸í•  ë•Œ = 0
SKIP_DB=1

## Key source files

### FILE: src/main.rs

mod state;
mod error;
mod api;
mod docs;

use std::env;
use tokio::net::TcpListener;
use sqlx::{Pool, Postgres};
use sqlx::postgres::PgPoolOptions;
use crate::state::AppState;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // 1) .env ë¡œë“œ(ì—†ì–´ë„ ê³„ì† ì§„í–‰)
    let _ = dotenvy::dotenv();

    // 2) í™˜ê²½ë³€ìˆ˜ ê¸°ë³¸ê°’
    let skip_db = env::var("SKIP_DB").unwrap_or_else(|_| "0".into()) == "1";
    let database_url = env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgres://postgres:postgres@127.0.0.1:5432/amk".into());
    let bind_addr = env::var("BIND_ADDR").unwrap_or_else(|_| "0.0.0.0:3000".into());

    // 3) í•­ìƒ lazy í’€ ìƒì„± (sqlx 0.7: Result ë°˜í™˜ â†’ ? ì²˜ë¦¬)
    let db: Pool<Postgres> = PgPoolOptions::new()
        .max_connections(10)
        .connect_lazy(&database_url)?; // â† ì¤‘ìš”

    // 4) ì‹¤ì œ ì—°ê²° í™•ì¸ì€ í•„ìš”í•  ë•Œë§Œ(ë¬¸ì„œë§Œ ë³¼ ë• SKIP_DB=1ë¡œ ê±´ë„ˆëœ€)
    if !skip_db {
        sqlx::query("SELECT 1").execute(&db).await?;
    }

    // 5) ë¼ìš°í„° (âš ï¸ Swagger UIëŠ” api::app_router ìª½ì— ì´ë¯¸ ë“±ë¡ë˜ì–´ ìˆë‹¤ê³  ê°€ì •)
    let app_state = AppState { db };
    let app = api::app_router(app_state);

    // 6) ì„œë²„ ì‹œì‘
    let listener = TcpListener::bind(&bind_addr).await?;
    println!("âœ… Server running at http://{bind_addr}");
    println!("ğŸ“˜ If Swagger UI is enabled in the router, open: http://{bind_addr}/docs");

    axum::serve(listener, app).await?;
    Ok(())
}

### FILE: src/docs.rs

use utoipa::{Modify, OpenApi};
use utoipa::openapi::security::{HttpAuthScheme, HttpBuilder, SecurityScheme};

pub struct SecurityAddon;

impl Modify for SecurityAddon {
    fn modify(&self, openapi: &mut utoipa::openapi::OpenApi) {
        let components = openapi.components.get_or_insert(Default::default());
        // âœ¨ JWT ë³´ì•ˆ ìŠ¤í‚¤ë§ˆëŠ” HttpBuilderë¥¼ ì‚¬ìš©í•´ì•¼ bearer_format ì„¤ì • ê°€ëŠ¥
        components.add_security_scheme(
            "bearer_auth",
            SecurityScheme::Http(
                HttpBuilder::new()
                    .scheme(HttpAuthScheme::Bearer)
                    .bearer_format("JWT")
                    .build(),
            ),
        );
    }
}

#[derive(OpenApi)]
#[openapi(
    info(title = "Amazing Korean API", version = "1.0.0"),
    paths(
        crate::api::auth::handler::signup,
        crate::api::auth::handler::login,
        crate::api::auth::handler::me,
    ),
    components(
        schemas(
            crate::api::auth::dto::SignUpReq,
            crate::api::auth::dto::LoginReq,
            crate::api::auth::dto::LoginResp,
            crate::api::auth::dto::UserOut,
            crate::error::ErrorBody,
        )
    ),
    modifiers(&SecurityAddon),
    tags(
        (name = "auth", description = "Authentication")
    )
)]
pub struct ApiDoc;

### FILE: src/error.rs

use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde::Serialize;
use thiserror::Error;
use utoipa::ToSchema;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("bad request: {0}")]
    BadRequest(String),

    #[error("unauthorized: {0}")]
    Unauthorized(String),

    #[allow(dead_code)] // ì•„ì§ ë¯¸ì‚¬ìš©ì´ë©´ ê²½ê³  ì–µì œ
    #[error("forbidden")]
    Forbidden,

    #[error("not found")]
    NotFound,

    #[error("conflict: {0}")]
    Conflict(String),

    #[error("internal: {0}")]
    Internal(String),

    // í•„ìš” ì‹œ ìœ ì§€
    #[error(transparent)]
    Sqlx(#[from] sqlx::Error),

    #[error(transparent)]
    Anyhow(#[from] anyhow::Error),
}

pub type AppResult<T> = Result<T, AppError>;

#[derive(Serialize, ToSchema)]
pub struct ErrorBody {
    pub error: String,
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let status = match self {
            AppError::BadRequest(_) => StatusCode::BAD_REQUEST,
            AppError::Unauthorized(_) => StatusCode::UNAUTHORIZED,
            AppError::Forbidden => StatusCode::FORBIDDEN,
            AppError::NotFound => StatusCode::NOT_FOUND,
            AppError::Conflict(_) => StatusCode::CONFLICT,
            AppError::Sqlx(_) | AppError::Anyhow(_) | AppError::Internal(_) => {
                StatusCode::INTERNAL_SERVER_ERROR
            }
        };
        (status, Json(ErrorBody { error: self.to_string() })).into_response()
    }
}

### FILE: src/state.rs

use sqlx::PgPool;

#[derive(Clone)]
pub struct AppState {
    pub db: PgPool,
}

#[allow(dead_code)]
fn _assert_state_traits()
where
    AppState: Clone + Send + Sync + 'static,
{}
### FILE: src/api/mod.rs

use axum::{routing::get};
use crate::state::AppState;

use utoipa::OpenApi;
use utoipa_swagger_ui::SwaggerUi;
use crate::docs::ApiDoc;        

pub mod course;
pub mod auth;

use self::course::router::course_router;
use self::auth::router::auth_router;

pub fn app_router(state: AppState) -> axum::Router {
    axum::Router::new()
        .merge(course_router())
        .merge(auth_router())
        .route("/healthz", get(|| async { "ok" }))
        .merge(SwaggerUi::new("/docs").url("/api-docs/openapi.json", ApiDoc::openapi()))
        .with_state(state)
}

### FILE: src/api/auth/dto.rs

use serde::{Deserialize, Serialize};
use validator::Validate;
use utoipa::ToSchema;

/// íšŒì›ê°€ì… ìš”ì²­
#[derive(Serialize, Deserialize, Validate, ToSchema)]
pub struct SignUpReq {
    #[validate(email)]
    pub email: String,
    #[validate(length(min = 6, max = 72))]
    pub password: String,
    #[validate(length(min = 1, max = 50))]
    pub name: String,

    /// ì•½ê´€ ë™ì˜
    pub terms_service: bool,
    pub terms_personal: bool,
}

/// ë¡œê·¸ì¸ ìš”ì²­
#[derive(Serialize, Deserialize, Validate, ToSchema)]
pub struct LoginReq {
    #[validate(email)]
    pub email: String,
    #[validate(length(min = 6, max = 72))]
    pub password: String,
}

/// ë¡œê·¸ì¸ ì‘ë‹µ(JWT)
#[derive(Serialize, ToSchema)]
pub struct LoginResp {
    /// JWT ì•¡ì„¸ìŠ¤ í† í°
    pub access_token: String,
    /// "Bearer"
    pub token_type: String,
    /// ë§Œë£Œ(ì´ˆ)
    pub expires_in: i64,
}

/// ê³µê°œìš© ì‚¬ìš©ì ì‘ë‹µ
#[derive(Serialize, sqlx::FromRow, ToSchema)]
pub struct UserOut {
    pub user_id: i64,
    pub user_email: String,
    pub user_name: Option<String>,
    pub user_created_at: chrono::DateTime<chrono::Utc>,
    pub user_state: String,
    pub user_auth: String,
}

### FILE: src/api/auth/handler.rs

use axum::{
    extract::State,
    http::{HeaderMap, StatusCode},
    Json,
};
use validator::Validate;

use crate::{
    error::{AppError, AppResult},
    state::AppState,
};
use super::{
    dto::{LoginReq, LoginResp, SignUpReq, UserOut},
    jwt,
    service::AuthService,
};

#[utoipa::path(
    post,
    path = "/auth/signup",
    tag = "auth",
    request_body = SignUpReq,
    responses(
        (status = 201, description = "User created"),
        (status = 400, description = "Bad request", body = crate::error::ErrorBody),
        (status = 409, description = "Email already exists", body = crate::error::ErrorBody)
    )
)]
pub async fn signup(
    State(st): State<AppState>,
    Json(req): Json<SignUpReq>,
) -> AppResult<(StatusCode, Json<serde_json::Value>)> {
    req.validate()
        .map_err(|e| AppError::BadRequest(e.to_string()))?;

    // âœ¨ ì‹œê·¸ë‹ˆì²˜ì— ë§ê²Œ ê°œë³„ ì¸ì ì „ë‹¬
    AuthService::signup(
        &st,
        req.email.as_str(),
        req.password.as_str(),
        req.name.as_str(),
        req.terms_service,
        req.terms_personal,
    )
    .await?;

    Ok((StatusCode::CREATED, Json(serde_json::json!({"ok": true}))))
}

#[utoipa::path(
    post,
    path = "/auth/login",
    tag = "auth",
    request_body = LoginReq,
    responses(
        (status = 200, body = LoginResp),
        (status = 400, description = "Bad request", body = crate::error::ErrorBody),
        (status = 401, description = "Unauthorized", body = crate::error::ErrorBody)
    )
)]
pub async fn login(
    State(st): State<AppState>,
    Json(req): Json<LoginReq>,
) -> AppResult<Json<LoginResp>> {
    req.validate()
        .map_err(|e| AppError::BadRequest(e.to_string()))?;

    // âœ¨ ì„œë¹„ìŠ¤ ë°˜í™˜ì€ (access_token, expires_in, user) íŠœí”Œì´ë¯€ë¡œ êµ¬ì¡°ë¶„í•´
    let (access_token, expires_in, _user): (String, i64, UserOut) =
        AuthService::login(&st, req.email.as_str(), req.password.as_str()).await?;

    let resp = LoginResp {
        access_token,
        token_type: "Bearer".to_string(),
        expires_in,
    };
    Ok(Json(resp))
}

#[utoipa::path(
    get,
    path = "/auth/me",
    tag = "auth",
    responses(
        (status = 200, body = UserOut),
        (status = 401, description = "Unauthorized", body = crate::error::ErrorBody)
    ),
    security(("bearer_auth" = []))
)]
pub async fn me(
    State(st): State<AppState>,
    headers: HeaderMap,
) -> AppResult<Json<UserOut>> {
    let token = bearer_from_headers(&headers)?;
    let claims =
        jwt::decode_token(&token).map_err(|_| AppError::Unauthorized("invalid token".into()))?;
    let user = AuthService::me(&st, claims.sub).await?;
    Ok(Json(user))
}

/// Authorization: Bearer <token> í—¤ë”ì—ì„œ í† í° ì¶”ì¶œ
fn bearer_from_headers(headers: &HeaderMap) -> AppResult<String> {
    let auth = headers
        .get(axum::http::header::AUTHORIZATION)
        .and_then(|v| v.to_str().ok())
        .ok_or_else(|| AppError::Unauthorized("missing Authorization header".into()))?;

    let Some(rest) = auth.strip_prefix("Bearer ") else {
        return Err(AppError::Unauthorized(
            "invalid Authorization scheme".into(),
        ));
    };
    Ok(rest.to_string())
}

### FILE: src/api/auth/service.rs

use argon2::{Argon2, PasswordHasher, PasswordVerifier};
use password_hash::{PasswordHash, /*PasswordHasher as _*/SaltString};
use rand_core::OsRng;

use crate::{error::{AppError, AppResult}, state::AppState};
use super::{repo, dto::UserOut, jwt};

pub struct AuthService;

impl AuthService {
    pub async fn signup(
        st: &AppState,
        email: &str,
        password: &str,
        name: &str,
        terms_service: bool,
        terms_personal: bool,
    ) -> AppResult<i64> {
        if repo::find_by_email(&st.db, email).await?.is_some() {
            return Err(AppError::Conflict("email already exists".into()));
        }

        let salt = SaltString::generate(&mut OsRng);
        let hash = Argon2::default()
            .hash_password(password.as_bytes(), &salt)
            .map_err(|e| AppError::Internal(e.to_string()))?
            .to_string();

        // UNIQUE ìœ„ë°˜(ë™ì‹œê°€ì… ë“±)ì€ ì—¬ê¸°ì„œë„ ì¡ì•„ì¤€ë‹¤.
        let res = repo::create_user(&st.db, email, &hash, name, terms_service, terms_personal).await;
        match res {
            Ok(user_id) => Ok(user_id),
            Err(AppError::Sqlx(sqlx::Error::Database(db_err))) if db_err.code().as_deref() == Some("23505") => {
                Err(AppError::Conflict("email already exists".into()))
            }
            Err(e) => Err(e), // ë‚˜ë¨¸ì§€ëŠ” ê·¸ëŒ€ë¡œ ì „íŒŒ (Internal/Sqlx ë“±)
        }
    }

    pub async fn login(st: &AppState, email: &str, password: &str) -> AppResult<(String, i64, UserOut)> {
        let user = repo::find_by_email(&st.db, email).await?
            .ok_or(AppError::Unauthorized("invalid credentials".into()))?;

        let parsed = PasswordHash::new(&user.user_password)
            .map_err(|_| AppError::Unauthorized("invalid credentials".into()))?;

        Argon2::default()
            .verify_password(password.as_bytes(), &parsed)
            .map_err(|_| AppError::Unauthorized("invalid credentials".into()))?;

        if user.user_state != "on" {
            return Err(AppError::Unauthorized("user is not active".into()));
        }

        let (token, expires_in) = jwt::encode_token(user.user_id)
            .map_err(|e| AppError::Internal(e.to_string()))?;

        let out = UserOut {
            user_id: user.user_id,
            user_email: user.user_email,
            user_name: user.user_name,
            user_created_at: user.user_created_at,
            user_state: user.user_state,
            user_auth: user.user_auth,
        };

        Ok((token, expires_in, out))
    }

    pub async fn me(st: &AppState, user_id: i64) -> AppResult<UserOut> {
        let out = repo::get_user_out(&st.db, user_id).await?
            .ok_or(AppError::NotFound)?;
        Ok(out)
    }
}

### FILE: src/api/course/dto.rs

use serde::{Deserialize, Serialize};
use validator::Validate;

// SQL ê²°ê³¼ë¥¼ ì´ êµ¬ì¡°ì²´ë¡œ ë°”ë¡œ ë§¤í•‘í•  ê±°ë¼ FromRow íŒŒìƒ
#[derive(Serialize, sqlx::FromRow)]
pub struct CourseListItem {
    pub course_id: i64,
    pub course_title: String,
    pub course_price: i32,
    pub course_type: String,
    pub course_state: String,
}

#[derive(Deserialize, Validate)]
pub struct CreateCourseReq {
    #[validate(length(min = 1, max = 255))]
    pub title: String,
    pub price: i32,
    pub course_type: String,
    pub subtitle: Option<String>,
}

### FILE: src/api/course/handler.rs

use axum::{extract::{Path, State}, Json};
use validator::Validate;
use crate::{state::AppState, error::{AppError, AppResult}};
use super::{dto::{CourseListItem, CreateCourseReq}, service::CourseService};

pub async fn list(State(st): State<AppState>) -> AppResult<Json<Vec<CourseListItem>>> {
    let items = CourseService::list(&st).await?;
    Ok(Json(items))
}

pub async fn create(
    State(st): State<AppState>,
    Json(payload): Json<CreateCourseReq>
) -> AppResult<Json<serde_json::Value>> {
    payload.validate().map_err(|e| AppError::BadRequest(e.to_string()))?;
    let id = CourseService::create(
        &st,
        &payload.title,
        payload.price,
        &payload.course_type,
        payload.subtitle.as_deref()
    ).await?;
    Ok(Json(serde_json::json!({ "course_id": id })))
}

pub async fn get_by_id(
    State(st): State<AppState>,
    Path(id): Path<i64>,
) -> AppResult<Json<CourseListItem>> {
    // â¬‡ï¸ ë§¤í¬ë¡œ ë²„ì „(!) ëŒ€ì‹  ì œë„¤ë¦­ ë²„ì „ ì‚¬ìš© â†’ ì»´íŒŒì¼ ì‹œ DB ì ‘ì† ë¶ˆí•„ìš”
    let row = sqlx::query_as::<_, CourseListItem>(r#"
        SELECT
            course_id,
            course_title,
            course_price,
            course_type,
            course_state
        FROM course
        WHERE course_id = $1
    "#)
    .bind(id)
    .fetch_optional(&st.db)
    .await?;

    match row {
        Some(course) => Ok(Json(course)),
        None => Err(AppError::NotFound.into()),
    }
}

### FILE: src/api/course/service.rs

use crate::{state::AppState, error::AppResult};
use super::{repo, dto::CourseListItem};

pub struct CourseService;

impl CourseService {
    pub async fn list(state: &AppState) -> AppResult<Vec<CourseListItem>> {
        repo::list(&state.db).await
    }

    pub async fn create(
        state: &AppState,
        title: &str,
        price: i32,
        ctype: &str,
        subtitle: Option<&str>
    ) -> AppResult<i64> {
        repo::create(&state.db, title, price, ctype, subtitle).await
    }
}

## last cargo check output
error: failed to parse manifest at `/home/kkryo/dev/amazing-korean-api/Cargo.toml`

Caused by:
  feature `edition2024` is required

  The package requires the Cargo feature called `edition2024`, but that feature is not stabilized in this version of Cargo (1.80.0 (376290515 2024-07-16)).
  Consider trying a newer version of Cargo (this may require the nightly release).
  See https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#edition-2024 for more information about the status of this feature.
