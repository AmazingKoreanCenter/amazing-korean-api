---
title: AMK_PIPELINE — Amazing Korean Development Pipeline
updated: 2026-02-10
owner: HYMN Co., Ltd. (Amazing Korean)
audience: AI agents / lead / developer
---

## AMK_PIPELINE — Amazing Korean Development Pipeline

> 이 문서는 **멀티 AI 오케스트레이션 및 개발 작업 흐름의 기준 문서**이다.

> 규칙/스펙은 [`AMK_API_MASTER.md`](./AMK_API_MASTER.md), 배포/운영은 [`AMK_DEPLOY_OPS.md`](./AMK_DEPLOY_OPS.md)를 참조한다.

---

## 목차 (Table of Contents)

- [1. 개요 (Overview)](#1-개요-overview)
  - [1.1 목적과 범위](#11-목적과-범위)
  - [1.2 핵심 철학](#12-핵심-철학)
  - [1.3 용어 정의](#13-용어-정의)
  - [1.4 관련 문서](#14-관련-문서)
  - [1.5 도입 단계](#15-도입-단계)
- [2. 파이프라인 아키텍처 (Pipeline Architecture)](#2-파이프라인-아키텍처-pipeline-architecture)
  - [2.1 전체 작업 흐름도](#21-전체-작업-흐름도)
  - [2.2 단계별 정의](#22-단계별-정의)
  - [2.3 단계 간 전환 조건](#23-단계-간-전환-조건)
- [3. 역할 분리 (Role Separation)](#3-역할-분리-role-separation)
  - [3.1 역할의 두 가지 성격](#31-역할의-두-가지-성격)
  - [3.2 AI 모델별 역할 배치](#32-ai-모델별-역할-배치)
  - [3.3 기획 역할 운영 규칙](#33-기획-역할-운영-규칙)
  - [3.4 실행 역할 운영 규칙](#34-실행-역할-운영-규칙)
  - [3.5 창의적 이탈 처리](#35-창의적-이탈-처리)
  - [3.6 플랫폼별 역할 배치](#36-플랫폼별-역할-배치)
- [4. 작업 문서화 (Work Documentation)](#4-작업-문서화-work-documentation)
  - [4.1 작업 단위 정의](#41-작업-단위-정의)
  - [4.2 디렉터리 구조](#42-디렉터리-구조)
  - [4.3 태스크 파일 템플릿](#43-태스크-파일-템플릿)
  - [4.4 문서화 시점](#44-문서화-시점)
  - [4.5 세션 간 연속성 보장](#45-세션-간-연속성-보장)
- [5. 메신저 연동 (Messenger Integration)](#5-메신저-연동-messenger-integration)
  - [5.1 알림 대상 이벤트](#51-알림-대상-이벤트)
  - [5.2 연동 채널 및 우선순위](#52-연동-채널-및-우선순위)
  - [5.3 사용자 개입 요청](#53-사용자-개입-요청)
- [6. 샌드박스 환경 (Sandboxed Environment)](#6-샌드박스-환경-sandboxed-environment)
  - [6.1 격리 원칙](#61-격리-원칙)
  - [6.2 환경 구성](#62-환경-구성)
  - [6.3 안전장치](#63-안전장치)
- [7. 멀티 플랫폼 확장 (Multi-Platform Strategy)](#7-멀티-플랫폼-확장-multi-platform-strategy)
  - [7.1 현재 상태](#71-현재-상태)
  - [7.2 확장 계획](#72-확장-계획)
  - [7.3 플랫폼 간 공유 계층](#73-플랫폼-간-공유-계층)
  - [7.4 파이프라인 분기점](#74-파이프라인-분기점)
- [8. 품질 게이트 (Quality Gates)](#8-품질-게이트-quality-gates)
  - [8.1 단계별 게이트 정의](#81-단계별-게이트-정의)
  - [8.2 자동 vs 수동 검증](#82-자동-vs-수동-검증)
  - [8.3 실패 시 처리](#83-실패-시-처리)
- [9. 도구 선택 기준 (Tool Selection Criteria)](#9-도구-선택-기준-tool-selection-criteria)
  - [9.1 평가 기준](#91-평가-기준)
  - [9.2 후보 도구 평가](#92-후보-도구-평가)
  - [9.3 도구 교체 프로세스](#93-도구-교체-프로세스)

---

## 1. 개요 (Overview)

### 1.1 목적과 범위

이 문서는 Amazing Korean 프로젝트의 **개발 작업 흐름**과 **멀티 AI 오케스트레이션** 체계를 정의한다.

**다루는 것:**
- 기획부터 배포까지의 전체 작업 흐름
- AI 모델별 역할 배치 및 협업 규칙
- 작업 문서화, 메신저 연동, 샌드박스 환경
- 멀티 플랫폼 확장 시 파이프라인 분기

**다루지 않는 것:**
- 코드 스펙/규칙 → [`AMK_API_MASTER.md`](./AMK_API_MASTER.md)
- 배포/인프라 구현 → [`AMK_DEPLOY_OPS.md`](./AMK_DEPLOY_OPS.md)
- 코드 패턴/예시 → [`AMK_CODE_PATTERNS.md`](./AMK_CODE_PATTERNS.md)

### 1.2 핵심 철학

> **"도구가 파이프라인을 만드는 게 아니라, 파이프라인이 도구를 선택한다."**

파이프라인(작업 흐름)을 먼저 설계하고, 그 흐름에 맞는 도구를 선택한다.
특정 도구(Agent Teams, OpenClaw 등)에 종속되지 않는 구조를 유지한다.
도구가 바뀌어도 파이프라인은 그대로 작동해야 한다.

### 1.3 용어 정의

| 용어 | 정의 |
|------|------|
| **오케스트레이터** | 작업 흐름을 관리하고 AI들에게 작업을 배분하는 주체 (사용자 또는 도구) |
| **기획 역할** | "무엇을, 어떻게" 할지 사고하고 계획을 수립하는 AI의 역할 |
| **실행 역할** | 기획에서 확정된 지시를 받아 코드를 작성/테스트하는 AI의 역할 |
| **핸드오프** | 한 AI(또는 단계)에서 다음 AI(또는 단계)로 작업과 컨텍스트를 전달하는 행위 |
| **품질 게이트** | 다음 단계로 넘어가기 위해 반드시 통과해야 하는 검증 조건 |
| **샌드박스** | AI가 작업하는 격리된 실행 환경 (프로덕션과 분리) |
| **이탈 (Divergence)** | 기획 단계에서 프로젝트 방향과 다른 창의적 아이디어가 나오는 상황 |

### 1.4 관련 문서

| 문서 | 역할 | 관계 |
|------|------|------|
| [`AMK_API_MASTER.md`](./AMK_API_MASTER.md) | 규칙/스펙 (What) | 실행 단계에서 따르는 기준 |
| [`AMK_DEPLOY_OPS.md`](./AMK_DEPLOY_OPS.md) | 인프라/배포 (How to deploy) | 배포 단계의 기술 구현 |
| [`AMK_CODE_PATTERNS.md`](./AMK_CODE_PATTERNS.md) | 코드 패턴/예시 | 실행 단계에서 참조하는 코드 템플릿 |
| **AMK_PIPELINE.md** (본 문서) | 협업/작업 흐름 (How to work) | 전체 작업 흐름 및 AI 오케스트레이션 |

### 1.5 도입 단계

| 단계 | 상태 | 설명 |
|------|------|------|
| Phase 1 | 현재 | 1인 개발 + 단일 AI (Claude Code). 이 문서를 기준으로 작업 흐름 정립 |
| Phase 2 | 계획 | 멀티 AI 도입 (Claude + Gemini/ChatGPT). 역할 분리 적용 |
| Phase 3 | 계획 | 풀 오케스트레이션. 메신저 연동, 자동 핸드오프, 샌드박스 환경 운영 |

[맨 위로](#목차-table-of-contents)

---

## 2. 파이프라인 아키텍처 (Pipeline Architecture)

### 2.1 전체 작업 흐름도

| 순서 | 단계 | 영문 | 주체 | 핵심 활동 |
|:----:|------|------|------|----------|
| 1 | **기획** | Planning | 기획 AI (복수 모델) | 요구사항 분석, 기술 설계, 구현 계획 수립 |
| 2 | **검증** | Verify | 기획 AI (교차 검증) | 기획 타당성 검증, 누락/모순 확인, 대안 제시 |
| 3 | **지시** | Directive | **사용자** (최종 결정) | 기획 승인, 실행 범위 확정, 작업 지시 |
| 4 | **실행** | Execute | 실행 AI (코드 작성) | 코드 작성, 단위 테스트, 문서 동기화 |
| 5 | **리뷰** | Review | 기획 AI (코드 리뷰) | 코드 리뷰, 기획 대비 완성도 확인 |
| 6 | **QA** | QA Test | 실행 AI + 사용자 | 기능 테스트, 스모크 테스트, 버그 리포트 |
| 7 | **배포** | Deploy | CI/CD (자동 배포) | 빌드, 배포, 프로덕션 반영 |

> **흐름:** 기획 → 검증 → 지시 → 실행 → 리뷰 → QA → 배포
> **반복 가능:** 1↔2 (기획/검증), 4↔5 (실행/리뷰), 5↔6 (리뷰/QA)

### 2.2 단계별 정의

#### 1단계: 기획 (Planning)

| 항목 | 내용 |
|------|------|
| **주체** | 기획 역할 AI (복수 모델 가능) |
| **입력** | 사용자 요구사항, 기존 문서/코드 |
| **활동** | 요구사항 분석, 기술 설계, 구현 계획 수립 |
| **출력** | 기획 문서 (목표, 접근 방식, 변경 파일 목록, 예상 영향 범위) |

#### 2단계: 검증 (Verify)

| 항목 | 내용 |
|------|------|
| **주체** | 기획 역할 AI (기획과 다른 모델 권장) |
| **입력** | 1단계 기획 문서 |
| **활동** | 기획의 타당성 검증, 누락/모순 확인, 대안 제시 |
| **출력** | 검증 리포트 (승인/수정 요청/대안) |

> 사용자가 충분하다고 판단할 때까지 1-2단계를 반복할 수 있다.
> 사이클 종료 시점은 **사용자가 직접 결정**한다.

#### 3단계: 지시 (Directive)

| 항목 | 내용 |
|------|------|
| **주체** | **사용자** (유일한 지시 주체) |
| **입력** | 검증 완료된 기획 문서 |
| **활동** | 기획 승인, 실행 범위 확정, 작업 지시 |
| **출력** | 확정된 작업 지시서 |

> 이 단계는 반드시 사용자가 개입한다. AI가 스스로 실행 단계로 넘어가지 않는다.

#### 4단계: 실행 (Execute)

| 항목 | 내용 |
|------|------|
| **주체** | 실행 역할 AI |
| **입력** | 확정된 작업 지시서 |
| **활동** | 코드 작성, 테스트, 문서 동기화 |
| **출력** | 구현 완료된 코드 + 테스트 결과 |
| **참조** | 개별 작업 절차 → [`AMK_API_MASTER.md 7.2`](./AMK_API_MASTER.md#72-개발-플로우) |

#### 5단계: 리뷰 (Review)

| 항목 | 내용 |
|------|------|
| **주체** | 기획 역할 AI + 사용자 |
| **입력** | 실행 결과물 (코드, 테스트, 문서) |
| **활동** | 코드 리뷰, 기획 대비 완성도 확인, 문서 동기화 확인 |
| **출력** | 리뷰 리포트 (승인/수정 요청) |

#### 6단계: QA (QA Test)

| 항목 | 내용 |
|------|------|
| **주체** | 실행 역할 AI + 사용자 |
| **입력** | 리뷰 승인된 코드 |
| **활동** | 기능 테스트, 스모크 테스트, 브라우저 테스트, 버그 리포트 작성 |
| **출력** | QA 리포트 (통과/버그 목록) |
| **참조** | 테스트 기준 → [`AMK_API_MASTER.md 7.6`](./AMK_API_MASTER.md#76-테스트--자동화), 스모크 체크 → [`AMK_DEPLOY_OPS.md 7`](./AMK_DEPLOY_OPS.md#7-품질-보증--스모크-체크) |

> QA에서 버그가 발견되면 실행 단계(4)로 돌아가 수정 후 다시 리뷰(5) → QA(6)를 거친다.

#### 7단계: 배포 (Deploy)

| 항목 | 내용 |
|------|------|
| **주체** | CI/CD 자동화 + 사용자 승인 |
| **입력** | QA 통과된 코드 |
| **활동** | 빌드, 배포, 프로덕션 반영 |
| **출력** | 프로덕션 반영 |
| **참조** | 기술 구현 → [`AMK_DEPLOY_OPS.md 5`](./AMK_DEPLOY_OPS.md#5-github-actions-cicd-파이프라인) |

### 2.3 단계 간 전환 조건

| 순서 | 전환 | 조건 | 결정권자 |
|-----|------|------|----------|
| 1 | 기획 → 검증 | 기획 문서 작성 완료 | 기획 AI |
| 2 | 검증 → 기획 (반복) | 검증에서 문제 발견 | 기획 AI / 사용자 |
| 3 | 검증 → 지시 | 검증 통과 + 사용자 승인 | **사용자** |
| 4 | 지시 → 실행 | 사용자가 작업 지시 | **사용자** |
| 5 | 실행 → 리뷰 | 구현 완료 + 빌드/테스트 통과 | 실행 AI |
| 6 | 리뷰 → 실행 (반복) | 구현 검증에서 문제점 발견 시 수정 | 실행 AI / 사용자 |
| 7 | 리뷰 → QA | 코드 리뷰 승인 | 기획 AI / 사용자 |
| 8 | QA → 실행 (반복) | QA에서 문제점 발견 시 수정 | 실행 AI / 사용자 |
| 9 | QA → 배포 | QA 통과 + 사용자 승인 | **사용자** |
| 10 | 배포 → 실행 (반복) | 배포에서 문제점 발견 시 수정 | 실행 AI / 사용자  |

[맨 위로](#목차-table-of-contents)

---

## 3. 역할 분리 (Role Separation)

### 3.1 역할의 두 가지 성격

역할은 **일의 성격**에 따라 구분한다. 권한이나 위계가 아니다.

| 성격 | 하는 일 | 사고 방식 |
|------|---------|----------|
| **기획 (Planning)** | 무엇을, 어떻게 할지 결정 | 분석, 설계, 검증, 대안 탐색 |
| **실행 (Execution)** | 확정된 지시를 구현 | 코드 작성, 테스트, 문서 동기화 |

하나의 AI 모델이 두 역할을 겸할 수 있지만, **동시에 수행하지 않는다**.
기획 중에는 기획만, 실행 중에는 실행만 한다.

### 3.2 AI 모델별 역할 배치

> 아래는 초기 배치안이며, 프로젝트 진행에 따라 조정한다.

| AI 모델 | 주 역할 | 강점 | 비고 |
|---------|---------|------|------|
| **Claude** | 기획 + 실행 | 코드 품질, 문서화, 장문 컨텍스트 | 현재 주력 (Phase 1) |
| **Gemini** | 기획 (교차 검증) | 다양한 시각, 빠른 탐색 | Phase 2에서 도입 예정 |
| **ChatGPT** | 기획 (교차 검증) | 창의적 대안, 사용자 관점 | Phase 2에서 도입 예정 |

**모델 배치 원칙:**
- 기획 단계에서는 **복수 모델**을 활용하여 계획을 교차 검증한다
- 실행 단계에서는 **단일 모델**이 일관성 있게 작업한다
- 모델별 강점에 따라 역할을 배치하되, 특정 모델에 종속되지 않는다

### 3.3 기획 역할 운영 규칙

1. 기획 AI는 요구사항을 분석하고 **구현 계획을 문서로 출력**한다
2. 계획에는 반드시 포함: 목표, 접근 방식, 변경 파일 목록, 예상 영향 범위
3. 복수 AI를 사용할 경우, 각 AI가 **독립적으로** 계획을 검증한다
4. 검증 결과가 다를 경우, 차이점을 문서화하여 사용자에게 제시한다
5. 기획/검증 사이클의 종료는 **사용자가 직접 판단**한다

### 3.4 실행 역할 운영 규칙

1. 실행 AI는 **확정된 지시서만** 받아 작업한다
2. 지시 범위를 벗어나는 작업은 수행하지 않는다
3. 코드 작성 시 [`AMK_API_MASTER.md 0.4`](./AMK_API_MASTER.md#04-ai-에이전트-협업-규칙)의 공통 규칙을 따른다
4. 실행 중 예상치 못한 문제 발견 시, 작업을 중단하고 보고한다 (자의적 판단으로 범위를 확장하지 않는다)
5. 실행 완료 후 결과물을 문서화한다 (변경 사항, 테스트 결과, 주의점)

### 3.5 창의적 이탈 처리

기획 단계에서 프로젝트 방향과 다른 창의적 아이디어가 나올 수 있다.
이를 버리지 않고 **별도 문서로 기록**한다.

**이탈 기록 필수 항목:**

| 항목 | 설명 |
|------|------|
| **언제 (When)** | 어떤 기획 단계에서 발생했는지 |
| **누가 (Who)** | 어떤 AI 모델이 제안했는지 |
| **무엇을 (What)** | 아이디어의 핵심 내용 |
| **어떻게 (How)** | 구현 방법 (간략) |
| **왜 (Why)** | 왜 이 아이디어가 나왔는지, 기대 효과 |

> 실행 단계에서는 창의적 이탈이 구조적으로 발생하기 어렵다.
> 실행 AI는 지시된 작업만 수행하도록 설계되어 있기 때문이다.

### 3.6 플랫폼별 역할 배치

> Phase 2 이후, 멀티 플랫폼 확장 시 적용한다.

| 플랫폼 | 실행 AI | 기획 AI |
|--------|---------|---------|
| Web (React + Rust API) | Claude | 공유 |
| Android (스택 TBD) | TBD | 공유 |
| iOS (스택 TBD) | TBD | 공유 |

**원칙:** 기획은 플랫폼 간 **공유** (비즈니스 로직은 동일), 실행은 플랫폼별 **전담**.

[맨 위로](#목차-table-of-contents)

---

## 4. 작업 문서화 (Work Documentation)

### 4.1 작업 단위 정의

| 단위 | 규모 | 예시 | 문서 위치 |
|------|------|------|----------|
| **에픽 (Epic)** | 대규모 기능 | "결제 시스템 구축", "다국어 콘텐츠 확장" | `docs/epics/{epic-name}/` 폴더 |
| **태스크 (Task)** | 하나의 작업 세션에서 완료 가능한 단위 | "Stripe Webhook 처리 구현", "이메일 인증 시스템" | `docs/epics/{epic-name}/T{NNN}_{task-name}.md` 파일 |
| **서브태스크 (Subtask)** | 태스크 내 개별 작업 항목 | "결제 DTO 정의", "Webhook 라우터 추가" | 태스크 파일 내 체크리스트 |

### 4.2 디렉터리 구조

```
docs/epics/
├── payment-system/                         # Epic 폴더
│   ├── T001_stripe-webhook.md              # Task 파일
│   ├── T002_subscription-model.md
│   └── T003_payment-ui.md
├── i18n-multilingual/
│   ├── T001_db-schema.md
│   └── T002_translation-api.md
└── email-verification/                     # 완료된 Epic도 보관
    ├── T001_email-sender-trait.md
    └── T002_frontend-verify-page.md
```

**네이밍 규칙:**
- Epic 폴더: `kebab-case` (소문자, 하이픈 구분)
- Task 파일: `T{NNN}_{kebab-case}.md` (NNN은 3자리 순번)
- 순번은 Epic 내에서 생성 순서 (재정렬하지 않음)

### 4.3 태스크 파일 템플릿

```markdown
# T001: Stripe Webhook 처리 구현

## 메타
| 항목 | 값 |
|------|-----|
| Epic | 결제 시스템 |
| 상태 | 대기 / 진행 중 / 리뷰 / QA / 완료 |
| 담당 | Claude (실행) |
| 생성일 | 2026-02-10 |
| 완료일 | - |

## 컨텍스트
왜 이 작업이 필요한지, 배경 설명

## 결정 사항
- 어떤 기술적 결정을 내렸고 왜

## Subtasks
- [ ] Webhook DTO 정의
- [ ] 라우터 추가
- [ ] 서명 검증 로직
- [ ] 에러 핸들링

## 변경 이력
| 파일 | 변경 내용 |
|------|----------|
| `src/api/payment/handler.rs` | Webhook 엔드포인트 추가 |
| `src/api/payment/dto.rs` | StripeEvent DTO 정의 |

## 테스트 결과
- `cargo check`: PASS
- `npm run build`: PASS

## 주의점
후속 작업 시 알아야 할 사항
```

### 4.4 문서화 시점

| 파이프라인 단계 | 기록 항목 | 담당 |
|---------------|----------|------|
| 기획 (1) | 메타, 컨텍스트, 초기 Subtasks | 기획 AI |
| 검증 (2) | 결정 사항 (검증 과정에서 확정된 내용) | 기획 AI |
| 실행 (4) | 변경 이력, Subtask 체크, 테스트 결과 | 실행 AI |
| 리뷰 (5) | 주의점, 리뷰 피드백 반영 내용 | 기획 AI |
| QA (6) | QA 결과 (통과/버그 목록) | 실행 AI + 사용자 |
| 배포 (7) | 상태를 "완료"로 변경, 완료일 기록 | 실행 AI |

### 4.5 세션 간 연속성 보장

| 도구 | 역할 | 갱신 시점 |
|------|------|----------|
| `docs/epics/` | 작업 상세 기록 (Epic/Task/Subtask) | 매 파이프라인 단계마다 |
| `MEMORY.md` (Claude 메모리) | 세션 간 요약/참조. 완료/대기 작업 목록 | 매 세션 종료 시 |
| `CLAUDE.md` (프로젝트 루트) | 매 세션 자동 로딩. 프로젝트 구조, 핵심 규칙 | 구조적 변경 시 |
| `docs/AMK_API_MASTER.md` | 스펙/규칙의 SSoT | 스펙 변경 시 |
| `docs/AMK_DEPLOY_OPS.md` | 배포/운영 가이드 | 인프라 변경 시 |

**역할 분리:**
- `docs/epics/` = **상세 기록** (모든 컨텍스트, 결정 사항, 변경 이력)
- `MEMORY.md` = **요약/참조** (어떤 Epic이 진행 중인지, 핵심 포인트만)

**원칙:** 새 세션에서 작업을 이어받는 AI는 `MEMORY.md` → 해당 Epic/Task 파일 순서로 읽으면 컨텍스트를 완전히 파악할 수 있어야 한다.

[맨 위로](#목차-table-of-contents)

---

## 5. 메신저 연동 (Messenger Integration)

### 5.1 알림 대상 이벤트

| 이벤트 | 우선순위 | 설명 |
|--------|----------|------|
| 빌드 실패 | **높음** | CI/CD 빌드 또는 테스트 실패 |
| 배포 완료 | 보통 | 프로덕션 배포 성공 |
| 리뷰 완료 | 보통 | 코드 리뷰 결과 도착 |
| 승인 대기 | **높음** | 사용자 의사결정이 필요한 시점 |
| 기획 검증 완료 | 보통 | 기획/검증 사이클 결과 |
| 장애 감지 | **긴급** | 프로덕션 서비스 이상 |

### 5.2 연동 채널 및 우선순위

| 채널 | 용도 | 상태 |
|------|------|------|
| Slack / Discord | 개발 알림 (빌드, 배포, 리뷰) | 후보 |
| Telegram | 긴급 알림 (장애, 승인 대기) | 후보 |
| GitHub Notifications | PR/Issue 기반 알림 | 현재 사용 가능 |

> 채널 선정은 Phase 2 도입 시 확정한다.

### 5.3 사용자 개입 요청

AI가 사용자 개입이 필요한 상황:

1. **기획 → 지시 전환**: 기획/검증 완료 후 사용자 승인 대기
2. **의사결정 분기**: 복수 방안 중 선택이 필요할 때
3. **예외 상황**: 실행 중 예상치 못한 문제 발생

알림 포맷:
```
[AMK] 승인 대기: [태스크 이름]
- 상태: 기획 검증 완료
- 필요 액션: 실행 지시 또는 수정 요청
- 상세: [링크]
```

[맨 위로](#목차-table-of-contents)

---

## 6. 샌드박스 환경 (Sandboxed Environment)

### 6.1 격리 원칙

- AI는 **격리된 환경**에서만 코드를 실행한다
- 프로덕션 환경에 **직접 접근하지 않는다**
- 각 AI의 작업 환경은 **독립적**이다 (다른 AI의 작업에 영향을 주지 않음)

### 6.2 환경 구성

| 환경 | 용도 | 격리 수준 |
|------|------|----------|
| **개발 (dev)** | AI가 코드를 작성하고 테스트 | Docker 컨테이너 (로컬) |
| **스테이징 (staging)** | 배포 전 통합 테스트 | 별도 Docker Compose 환경 |
| **프로덕션 (prod)** | 실제 서비스 | EC2 (AI 직접 접근 불가) |

**AI별 환경 분리 (Phase 2 이후):**
```
┌─────────────────────────────────┐
│         공유 리소스               │
│  (Git repo, 문서, 설정 파일)      │
├─────────────┬───────────────────┤
│  AI-A 컨테이너  │  AI-B 컨테이너    │
│  (실행 역할)    │  (실행 역할)      │
│  독립 DB/Redis  │  독립 DB/Redis   │
└─────────────┴───────────────────┘
```

### 6.3 안전장치

| 안전장치 | 설명 |
|----------|------|
| **프로덕션 접근 차단** | AI 환경에서 프로덕션 DB/서버 접근 불가 |
| **파괴적 명령 방지** | `rm -rf`, `DROP DATABASE`, `force push` 등 차단 또는 확인 요구 |
| **환경 변수 분리** | `.env` (dev), `.env.prod` (prod) 분리. AI는 `.env`만 접근 |
| **네트워크 격리** | AI 컨테이너는 외부 네트워크 접근 제한 (필요한 API만 허용) |
| **작업 범위 제한** | 실행 AI는 지시된 파일/디렉터리만 수정 가능 |

[맨 위로](#목차-table-of-contents)

---

## 7. 멀티 플랫폼 확장 (Multi-Platform Strategy)

### 7.1 현재 상태

| 구성 요소 | 기술 스택 | 상태 |
|----------|----------|------|
| 백엔드 API | Rust + Axum + SQLx + PostgreSQL + Redis | 운영 중 |
| 프론트엔드 (Web) | React + Vite + TypeScript + shadcn/ui | 운영 중 |
| 모바일 (Android) | - | 미착수 |
| 모바일 (iOS) | - | 미착수 |

### 7.2 확장 계획

| 플랫폼 | 기술 스택 | 빌드 환경 | 비고 |
|--------|----------|----------|------|
| Android | TBD | TBD | - |
| iOS | TBD | **Mac (필수)** | Mac Mini 필요 |

### 7.3 플랫폼 간 공유 계층

```
┌──────────────────────────────────────┐
│           백엔드 API (Rust)            │  ← 모든 플랫폼 공유
├──────────────────────────────────────┤
│         비즈니스 로직 / 스펙            │  ← AMK_API_MASTER.md
├────────────┬────────────┬────────────┤
│  Web       │  Android   │  iOS       │  ← 플랫폼별 UI
│  (React)   │  (TBD)     │  (TBD)     │
└────────────┴────────────┴────────────┘
```

**공유되는 것:** API 엔드포인트, 데이터 모델, 인증 흐름, 비즈니스 규칙
**공유되지 않는 것:** UI 컴포넌트, 플랫폼별 네이티브 기능, 빌드/배포 설정

### 7.4 파이프라인 분기점

멀티 플랫폼 시, 파이프라인은 다음 지점에서 분기한다:

| 단계 | 공유/분기 | 설명 |
|------|----------|------|
| 기획 | **공유** | 비즈니스 로직은 플랫폼 무관 |
| 검증 | **공유** | API 스펙 검증은 한 번만 |
| 지시 | **분기** | 플랫폼별 실행 지시 |
| 실행 | **분기** | 플랫폼별 AI가 독립 실행 |
| 리뷰 | **분기 + 통합** | 플랫폼별 리뷰 후, API 호환성 통합 확인 |
| QA | **분기** | 플랫폼별 기능 테스트 |
| 배포 | **분기** | 플랫폼별 배포 파이프라인 |

[맨 위로](#목차-table-of-contents)

---

## 8. 품질 게이트 (Quality Gates)

### 8.1 단계별 게이트 정의

| 단계 전환 | 게이트 | 설명 |
|----------|--------|------|
| 기획 → 검증 | 기획 문서 완성도 | 목표, 접근 방식, 변경 파일, 영향 범위 포함 여부 |
| 검증 → 지시 | 검증 통과 | 교차 검증에서 심각한 문제 없음 + 사용자 승인 |
| 실행 → 리뷰 | 빌드/테스트 통과 | 정적 가드 + 빌드 성공 |
| 리뷰 → QA | 리뷰 승인 | 코드 리뷰 통과 + 문서 동기화 확인 |
| QA → 배포 | QA 통과 | 기능 테스트 + 스모크 테스트 통과 + 사용자 승인 |

### 8.2 자동 vs 수동 검증

| 구분 | 항목 | 담당 |
|------|------|------|
| **자동** | `cargo check`, `cargo clippy`, `cargo fmt` | CI / 실행 AI |
| **자동** | `npm run build` (프론트엔드) | CI / 실행 AI |
| **자동** | 빌드 성공 여부 | CI |
| **수동** | 기획 문서 검토 | 기획 AI + 사용자 |
| **수동** | 코드 리뷰 | 기획 AI + 사용자 |
| **수동/자동** | 기능 테스트 (QA) | 실행 AI + 사용자 |
| **수동** | 스모크 테스트 (QA) | 사용자 |
| **수동** | 브라우저 테스트 (QA) | 사용자 |

> 테스트 기준/목표치 → [`AMK_API_MASTER.md 7.6, 8.4`](./AMK_API_MASTER.md#76-테스트--자동화) 참조
> 배포 시 체크리스트 → [`AMK_DEPLOY_OPS.md 7`](./AMK_DEPLOY_OPS.md#7-품질-보증--스모크-체크) 참조

### 8.3 실패 시 처리

| 실패 유형 | 처리 |
|----------|------|
| 빌드/테스트 실패 | 실행 단계(4)로 돌아가 수정 |
| 코드 리뷰 수정 요청 | 실행 단계(4)로 돌아가 수정 후 재리뷰 |
| QA 버그 발견 | 실행 단계(4)로 돌아가 수정 후 리뷰(5) → QA(6) 재진행 |
| 기획 검증 실패 | 기획 단계(1)로 돌아가 재설계 |
| 배포 실패 | 롤백 후 원인 분석 → 실행 단계(4)로 |

**원칙:** 실패 시 항상 **이전 단계로 돌아간다**. 게이트를 우회하지 않는다.

[맨 위로](#목차-table-of-contents)

---

## 9. 도구 선택 기준 (Tool Selection Criteria)

### 9.1 평가 기준

도구를 선택할 때 다음 기준으로 평가한다:

| 기준 | 설명 | 가중치 |
|------|------|--------|
| **파이프라인 적합성** | 우리 작업 흐름에 자연스럽게 맞는가? | 높음 |
| **도구 독립성** | 특정 도구에 종속되지 않는 구조를 유지할 수 있는가? | 높음 |
| **안정성** | 프로덕션 수준의 안정성이 있는가? (실험적 기능 주의) | 높음 |
| **통합 용이성** | 기존 도구/워크플로우와 쉽게 연동되는가? | 보통 |
| **비용** | 합리적인 비용인가? | 보통 |
| **확장성** | 멀티 플랫폼/멀티 AI 확장 시에도 사용 가능한가? | 보통 |

### 9.2 후보 도구 평가

| 도구 | 용도 | 평가 | 상태 |
|------|------|------|------|
| **Claude Code** | AI 코딩 에이전트 | 파이프라인 적합, 안정적 | 현재 사용 |
| **GitHub Actions** | CI/CD | 파이프라인 적합, 안정적 | 현재 사용 |
| **Docker** | 환경 격리 | 파이프라인 적합, 안정적 | 현재 사용 |
| **Agent Teams** | 멀티 AI 오케스트레이션 | 파이프라인 적합, **실험적 기능** | 관찰 중 |
| **OpenClaw** | 멀티 AI 오케스트레이션 | 파이프라인 적합, 통합 용이 | 평가 예정 |

> 현재 사용 중인 도구 목록 → [`AMK_DEPLOY_OPS.md 9`](./AMK_DEPLOY_OPS.md#9-운영-도구-목록) 참조

### 9.3 도구 교체 프로세스

1. **필요성 확인**: 현재 도구로 해결할 수 없는 문제가 있는가?
2. **후보 조사**: 9.1의 평가 기준으로 후보 도구를 비교
3. **PoC 테스트**: 작은 범위에서 후보 도구를 시험 적용
4. **의사결정**: 사용자가 도입 여부를 최종 결정
5. **점진적 도입**: 기존 도구와 병행 운영 후 전환
6. **문서 업데이트**: PIPELINE, DEPLOY_OPS 문서 동기화

**원칙:** 도구 교체는 항상 **점진적**으로 한다. 한 번에 전면 교체하지 않는다.

[맨 위로](#목차-table-of-contents)
