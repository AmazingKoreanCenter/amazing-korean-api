# Phase 6-41 Admin Bulk Update Lesson Items (PATCH /admin/lessons/bulk/items)

ROLE: Senior Rust Backend AI Assistant

OBJECTIVE:
- `PATCH /admin/lessons/bulk/items` 엔드포인트를 구현하여 여러 개의 수업 아이템을 한 번에 수정합니다.
- **핵심 패턴**: `admin_bulk_update_lessons`의 **"Loop + Individual Transaction (부분 성공 207)"** 패턴을 적용합니다.

CONTEXT (SSOT & Rules):
1.  **Identifier Strategy**:
    - `LESSON_ITEM`은 복합 키(`lesson_id`, `lesson_item_seq`)를 가집니다.
    - 따라서 Update Item DTO에는 **Target을 식별하기 위한 `lesson_id`, `current_seq`** 와 **변경할 값들(`new_seq`, `kind` 등)** 이 모두 포함되어야 합니다.

2.  **Logic Flow (Service)**:
    - 1) **API Log**: `user::repo::create_audit_log` (Action="BULK_UPDATE_LESSON_ITEMS").
    - 2) **Loop Processing**:
        - 각 아이템마다 **개별 트랜잭션**(`pool.begin()`)을 시작합니다.
        - **Validation 1 (Existence)**: `repo::find_lesson_item_tx(lesson_id, current_seq)` 호출.
            - 없으면 `404 Not Found`.
        - **Validation 2 (Seq Duplication)**:
            - 만약 `new_seq`가 `Some`이고 `current_seq`와 다르다면?
            - `repo::exists_lesson_item_tx(lesson_id, new_seq)` 확인.
            - 이미 존재하면 `409 Conflict` (순서 충돌).
        - **Update**: `repo::update_lesson_item_tx` 호출.
            - **Data Hygiene**: 단건 수정(Phase 6-40)과 동일하게, `kind` 변경 시 반대편 ID를 `NULL`로 처리하는 로직 적용 (또는 Repo 함수가 이를 처리하도록 재사용).
        - **Data Log**: `repo::create_lesson_log_tx` (Action="update").
        - **Commit**: 트랜잭션 종료.
        - **Result Collection**: 성공 시 `(lesson_id, seq)`, 실패 시 Error 수집.
    - 3) **Response**: 실패가 0건이면 `200 OK`, 1건이라도 있으면 `207 Multi-Status`.

3.  **DTO 설계 (Strict Requirement)**:
    - **`LessonItemBulkUpdateReq`**:
        - `items`: `Vec<LessonItemUpdateItem>`.
    - **`LessonItemUpdateItem`**:
        - `lesson_id`: `i32` (식별자 1).
        - `current_lesson_item_seq`: `i32` (식별자 2 - 현재 순서).
        - `new_lesson_item_seq`: `Option<i32>` (변경할 순서).
        - `lesson_item_kind`: `Option<String>`.
        - `video_id`: `Option<i32>`.
        - `study_task_id`: `Option<i32>`.

4.  **기술적 유의사항**:
    - **Code Reuse**: Phase 6-40에서 만든 `repo::update_lesson_item_tx` 함수를 그대로 재사용하세요. 이 함수는 `QueryBuilder`를 통해 동적 업데이트를 수행해야 합니다.
    - **Mapping**: DTO의 `new_lesson_item_seq`를 Repo 함수에 전달할 때, 필드명 매핑(`lesson_item_seq` 컬럼으로)에 주의하세요.

IMPLEMENTATION STEPS:

1.  **DTO (`src/api/admin/lesson/dto.rs`)**:
    - `LessonItemBulkUpdateReq`, `LessonItemUpdateItem`, `LessonItemBulkUpdateRes` 정의.

2.  **Repo (`src/api/admin/lesson/repo.rs`)**:
    - (Phase 6-40에서 이미 구현된 `find_lesson_item_tx`, `exists_lesson_item_tx`, `update_lesson_item_tx` 재사용).
    - 만약 `update_lesson_item_tx`가 `new_seq` 처리를 위해 별도의 인자를 받지 않는다면, DTO 변환 로직을 점검할 것.

3.  **Service (`src/api/admin/lesson/service.rs`)**:
    - `admin_bulk_update_lesson_items`: 부분 성공 로직(Loop + Tx) 구현.

4.  **Handler (`src/api/admin/lesson/handler.rs`)**:
    - 핸들러 구현 (200 vs 207).

5.  **Router & Docs**:
    - 라우터 등록 및 문서 업데이트.

FILE PATCHES START
// src/api/admin/lesson/dto.rs
// src/api/admin/lesson/repo.rs
// src/api/admin/lesson/service.rs
// src/api/admin/lesson/handler.rs
// src/api/admin/lesson/router.rs
// src/docs.rs
FILE PATCHES END