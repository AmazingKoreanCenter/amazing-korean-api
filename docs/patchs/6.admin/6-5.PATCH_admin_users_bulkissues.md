# 📝 Phase 6-5 Admin Bulk Update - Issue & Troubleshooting Log

## 1. 아키텍처 및 로직 설계 (Architecture & Logic)

### ✅ 부분 성공(Partial Success) 전략 구현
* **요구사항:** 대량 수정 요청 시, 일부 데이터가 실패(예: 이메일 중복)하더라도 나머지 데이터는 수정되어야 함 (HTTP 207).
* **문제:** Rust의 `?` 연산자(Error Propagation)는 에러 발생 시 즉시 함수를 종료시켜버림.
* **해결:**
    * `for` 루프 내부에서 `async { ... }` 블록을 사용하여 각 아이템 처리 로직을 격리.
    * `?` 연산자 대신 `match` 문을 사용하여 `Result`를 직접 분해.
    * 성공 시 `results` 벡터에 200 데이터를, 실패 시 에러 코드와 메시지를 담음.

---

## 2. 컴파일러 에러 및 기술적 이슈 (Technical Issues)

### 🔴 이슈 1: DB 연결 타입 불일치 (Pool vs Transaction)
* **에러 코드:** `E0308: mismatched types`
* **에러 메시지:** `expected reference &Pool<Postgres>, found mutable reference &mut PgConnection`
* **원인:**
    * `repo::admin_get_user` (조회)는 `&PgPool`을 인자로 요구함.
    * `repo::admin_update_user` (수정)는 `&mut Transaction`을 인자로 요구함.
    * Service 루프 내에서 **이미 시작된 트랜잭션(`&mut tx`)**을 조회 함수(`get_user`)에 억지로 넣으려다 발생.
* **해결:**
    * **읽기(Read):** 트랜잭션 시작 전에 `&st.db` (Pool)를 사용하여 조회 처리.
    * **쓰기(Write):** 데이터 검증 후 `st.db.begin()`으로 트랜잭션을 열고, `&mut tx`를 수정 함수에 전달.

### 🔴 이슈 2: 함수 시그니처(인자 개수) 불일치
* **에러 코드:** `E0061: this function takes 4 arguments but 5 arguments were supplied`
* **원인:**
    * **Repo 정의:** `fn admin_update_user(tx, user_id, req, password_hash)` -> **4개**
    * **Service 호출:** `admin_update_user(tx, actor_id, user_id, req, password_hash)` -> **5개**
    * Phase 6-4에서 정의한 Repo 함수에는 `actor_id`가 없었으나, Service 구현 시 관습적으로 `actor_id`를 넣으려다 발생.
* **해결:** `actor_id` 인자를 제거하고, Repo 정의에 맞춰 4개 인자만 정확히 전달.

### 🔴 이슈 3: 데이터 흐름 중복 (Password Logic)
* **상황:** 비밀번호 해시를 `req.password` 필드에도 넣고, 별도 인자 `password_hash`로도 넘기려 함.
* **문제:** Repo 입장에서는 "어떤 게 진짜 비밀번호야?"라는 혼란 발생 가능성 및 비효율.
* **해결:**
    * Service에서 비밀번호 해싱 수행.
    * `req.password`는 `None`으로 설정하여 DTO 내 혼선 방지.
    * 해싱된 값은 4번째 인자 `password_hash`로 명확하게 전달.

---

## 3. 핵심 배움 (Key Takeaways)

1.  **Repo 함수의 "계약" 준수:** Repo 함수가 `Pool`을 원하는지 `Transaction`을 원하는지, 인자 순서는 무엇인지 엄격하게 확인해야 한다. (Rust는 이를 컴파일 타임에 아주 깐깐하게 잡는다.)
2.  **트랜잭션의 범위(Scope):** `Read` 작업은 굳이 트랜잭션 안에 넣지 않아도 되는 경우(단순 조회), `Pool`을 사용하여 동시성을 높이고 락(Lock) 범위를 줄이는 것이 좋다.
3.  **에러 핸들링의 유연성:** 대량 처리(Bulk) 로직에서는 `?` 연산자에 의존하기보다, `match`를 통해 실패를 값(Value)으로 다루는 패턴이 필수적이다.