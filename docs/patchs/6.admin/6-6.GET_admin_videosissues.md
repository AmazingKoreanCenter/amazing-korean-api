# 📝 Phase 6-6 Admin List Videos - Issue & Troubleshooting Log

## 1. 데이터베이스 스키마 및 SQL 로직 (DB Schema & SQL)

### 🔴 이슈 1: 컬럼 부재 및 테이블 관계 파악 미흡
* **에러:** `column v.video_title does not exist`
* **원인:**
    * 초기 구현 시 `VIDEO` 테이블에 `title`, `description` 컬럼이 직접 존재한다고 가정함.
    * 실제 스키마는 `VIDEO` ↔ `VIDEO_TAG_MAP` ↔ `VIDEO_TAG` 형태로 정규화되어 있어, 제목과 설명이 `VIDEO_TAG` 테이블에 존재함.
* **해결:**
    * `LEFT JOIN`을 사용하여 3개의 테이블을 연결.
    * **`GROUP BY v.video_id`**와 **`MAX(t.video_tag_title)`**를 사용하여, 1:N 관계에서 중복 행이 발생하는 것을 방지하고 대표 제목을 추출함.

### 🔴 이슈 2: Rust vs PostgreSQL 타입 불일치 (Type Mismatch)
* **에러:** `mismatched types; Rust type i64 (as SQL type INT8) is not compatible with SQL type INT4`
* **원인:**
    * DB의 `video_id`는 `INT` (4바이트) 타입.
    * Rust DTO(`AdminVideoRes`)의 `id`는 `i64` (8바이트) 타입.
    * `sqlx`는 데이터 손실 방지를 위해 암묵적 형변환을 허용하지 않음.
* **해결:** SQL 쿼리 레벨에서 명시적 캐스팅(`::bigint`)을 적용.
    ```sql
    v.video_id::bigint AS id
    ```

---

## 2. 아키텍처 및 도구 활용 (Architecture & Tools)

### ✅ 동적 쿼리 빌더 (QueryBuilder) 도입
* **배경:** 검색어(`q`), 정렬 필드(`sort`), 정렬 방향(`order`)이 있을 때마다 SQL 문자열을 직접 조합하는 것은 SQL Injection 위험이 있고 코드가 지저분해짐.
* **해결:** `sqlx::QueryBuilder`를 도입하여 조건부 `WHERE` 절과 `ORDER BY` 절을 안전하고 깔끔하게 구성함. `push_bind()`를 통해 파라미터를 안전하게 바인딩함.

### ✅ 트랜잭션 전략 (Transaction Strategy)
* **결정:** `GET` 요청(조회)에는 트랜잭션(`tx.begin()`)을 걸지 않음.
* **이유:** 단순 조회 시 트랜잭션 락(Lock)으로 인한 성능 저하를 방지하기 위함.
* **구현:**
    * 데이터 조회: `Repo`에 `&PgPool`을 전달하여 수행.
    * 감사 로그(Audit Log): 조회와 별개로 `Pool`을 사용하여 로그 기록. (조회 실패가 로그 실패로 이어지지 않도록 독립적 처리)

---

## 3. 핵심 배움 (Key Takeaways)

1.  **스키마 확인의 중요성:** 코드를 짜기 전에 `\d table_name`으로 실제 컬럼명과 타입을 확인하는 습관이 시행착오를 줄여준다.
2.  **SQLx의 엄격함:** `INT` vs `BIGINT` 차이는 항상 염두에 두어야 하며, DTO를 `i64`로 통일했다면 SQL에서 `::bigint` 캐스팅은 필수 공식이다.
3.  **복잡한 쿼리의 DTO 매핑:** `JOIN`이나 `GROUP BY`가 들어간 쿼리는 `sqlx::FromRow` 매크로가 자동으로 처리하기 어려울 수 있으므로, 쿼리 내에서 `AS alias`를 사용하여 DTO 필드명과 정확히 일치시켜야 한다.