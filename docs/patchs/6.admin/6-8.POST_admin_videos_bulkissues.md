# 📝 Phase 6-8 Admin Bulk Create Videos - Issue & Troubleshooting Log

## 1. 아키텍처 및 트랜잭션 전략 (Architecture & Transaction Strategy)

### ✅ 부분 성공(Partial Success)을 위한 트랜잭션 격리
* **과제:** 대량의 비디오 생성 요청 중 하나만 실패(예: 중복 키)해도 전체가 롤백되면 사용자 경험이 좋지 않음.
* **해결:**
    * **Loop 내부 트랜잭션:** `for` 루프 안에서 매번 `st.db.begin()`을 호출하여 **각 아이템마다 독립적인 트랜잭션**을 생성.
    * **결과 집계:** 성공 시 `commit()` 후 201 목록에 추가, 실패 시 `rollback()`(자동) 후 에러 메시지를 결과 목록에 추가.
    * **HTTP 207:** 실패가 하나라도 있으면 `207 Multi-Status`를 반환하여 클라이언트가 성공/실패를 구분할 수 있게 함.

### ✅ 리포지토리(Repo) 재사용성 극대화
* **상황:** 비디오 생성은 3개 테이블(`VIDEO`, `TAG`, `MAP`)에 Insert해야 하는 복잡한 로직임. 이를 벌크용으로 새로 짜면 코드가 중복됨.
* **해결:**
    * 기존 `repo::admin_create_video` 함수가 `&mut Transaction`을 인자로 받도록 설계되어 있었음.
    * 서비스 레이어에서 트랜잭션만 열어서 던져주는 방식으로 **기존 단건 생성 로직을 100% 재사용**함.

---

## 2. 데이터 무결성 및 로직 일관성 (Consistency)

### ✅ 스키마 제약조건 준수 (UUID 길이)
* **이슈:** Phase 6-7에서 겪었던 `video_tag_key`의 30자 길이 제한(`varchar(30)`).
* **적용:** 벌크 생성 로직에서도 자동 생성 시 UUID를 슬라이싱(`&uuid[..20]`)하는 로직을 동일하게 적용하여 `value too long` 에러를 사전에 방지함.

### ✅ DTO와 DB 컬럼명 통일의 효과
* **성과:** 요청 DTO(`VideoCreateReq`)의 필드명을 DB 컬럼명(`video_tag_title` 등)과 완전히 일치시킴.
* **결과:** 데이터 매핑 과정에서 혼동이 사라졌고, Swagger 문서와 실제 DB 구조가 일치하여 개발 속도가 빨라짐.

---

## 3. 핵심 배움 (Key Takeaways)

1.  **어려운 문제를 먼저 해결하면 확장이 쉽다:** 단건 생성(6-7)에서 고생하며 타입을 맞추고 트랜잭션을 정립해둔 덕분에, 다중 생성(6-8)은 반복문 로직만 추가하면 되는 '보너스 스테이지'가 되었다.
2.  **트랜잭션의 범위 관리:** `Service` 레이어에서 트랜잭션의 시작과 끝(`commit/rollback`)을 관리하고, `Repo` 레이어는 `Transaction` 객체만 받아서 수행하는 패턴이 **재사용성**과 **원자성(Atomicity)** 제어에 매우 효과적이다.