# 📝 Dev Notes: Phase 3-4 Implementation (POST /videos/{id}/progress)

## 📋 개요
- **작업**: 비디오 진행률 갱신 API (`POST /videos/{id}/progress`)
- **기간**: 2025.12.31
- **성격**: Data Upsert (Insert + Update), Unique Constraint Migration, Input Validation

---

## 🛠️ 트러블슈팅 및 주요 기술적 의사결정 (Troubleshooting & Decisions)

### 1. Upsert(Create or Update) 전략 수립
- **과제**: 사용자가 비디오를 처음 볼 때는 `INSERT`, 보던 것을 이어서 볼 때는 `UPDATE`가 필요함. 이를 애플리케이션 레벨에서 `SELECT` 후 분기 처리하면 쿼리가 2번 발생하고 동시성 문제가 생길 수 있음.
- **해결**: PostgreSQL의 **`INSERT ... ON CONFLICT (user_id, video_id) DO UPDATE`** 구문 사용.
- **전제 조건**: 이를 위해서는 `video_log` 테이블에 `(user_id, video_id)` 조합에 대한 **UNIQUE Constraint**가 필수적임.
- **조치**: 마이그레이션을 통해 `uk_video_log_user_video` 제약 조건을 추가하여 DB 레벨에서 무결성을 보장하고 Upsert 쿼리 기반을 마련함.

### 2. 비즈니스 로직의 캡슐화 (Completion Logic)
- **요구사항**: 진행률이 100%가 되면 `is_completed` 필드도 자동으로 `true`가 되어야 함.
- **구현**: 클라이언트가 `is_completed`를 직접 보내게 하지 않고, 서버 Service 계층에서 `req.progress_rate == 100` 조건을 체크하여 자동으로 플래그를 설정하도록 구현. 이는 클라이언트의 부담을 줄이고 데이터 일관성을 서버가 통제하는 좋은 패턴임.

### 3. 입력 데이터 검증 (Defensive Coding)
- **위험 요소**: 클라이언트가 `-50`이나 `200` 같은 비정상적인 퍼센트 값을 보낼 가능성.
- **해결**: `validator` 크레이트의 `#[validate(range(min = 0, max = 100))]` 어노테이션을 DTO에 적용.
- **결과**: 비즈니스 로직에 진입하기 전에 유효하지 않은 데이터를 `422 Unprocessable Entity`로 조기 차단.

---

## 🔑 확립된 핵심 개발 패턴 (Key Patterns)

### 1. Atomic Upsert
- **패턴**: 데이터 존재 여부를 확인하고 넣는 로직(Check-then-Act)을 피하고, DB의 Atomic한 연산(`ON CONFLICT`)을 활용하여 동시성 문제 해결 및 성능 최적화.

### 2. Migration Driven Development
- **패턴**: 기능 구현 중 DB 스키마 제약이 필요할 때(예: Upsert를 위한 Unique Key), 코드를 짜다 말고 즉시 마이그레이션 파일을 생성하여 DB 구조부터 단단히 잡고 가는 방식.

---

## ✅ 결론
- **구현 완료**: 시청 기록 저장 및 갱신 기능 완벽 동작 확인.
- **데이터 무결성**: 중복 데이터 방지(Unique Key) 및 입력 값 범위 제한(Validation) 적용 완료.
- **Phase 3 완료**: 비디오 목록 조회, 상세 조회, 진행률 조회, 진행률 저장까지 **Video 도메인의 핵심 CRUD 사이클** 완성.