# 📝 Dev Notes: Phase 3-2 Implementation (GET /videos/{id})

## 📋 개요
- **작업**: 비디오 상세 조회 API (`GET /videos/{id}`)
- **기간**: 2025.12.31
- **성격**: Detail View, JSON Aggregation, Error Handling (404)

---

## 🛠️ 트러블슈팅 및 주요 기술적 의사결정 (Troubleshooting & Decisions)

### 1. DB 레벨에서의 JSON 집계 (Server-Side JSON Composition)
- **과제**: 상세 조회 시, 비디오 정보와 연결된 태그의 상세 정보(Key, Title, Subtitle)를 한 번의 쿼리로 구조화해서 가져와야 함.
- **해결**: PostgreSQL의 강력한 JSON 함수 활용.
  - `jsonb_build_object`: 컬럼들을 키-값 쌍의 JSON 객체로 생성.
  - `jsonb_agg`: 여러 행(Tags)을 하나의 JSON 배열로 집계.
  - `COALESCE(..., '[]'::jsonb)`: 태그가 하나도 없는 경우 `null` 대신 빈 배열(`[]`)을 반환하여 클라이언트 파싱 에러 방지.

### 2. Rust 타입 매핑 자동화 (sqlx::types::Json)
- **과제**: DB에서 만들어진 JSONB 데이터를 Rust 구조체로 어떻게 변환할 것인가?
- **해결**: `sqlx`의 `Json` 래퍼 타입 사용.
  - DTO 정의: `pub tags: Json<Vec<VideoTagDetail>>`
  - 효과: 별도의 파싱 로직 없이, 쿼리 결과가 자동으로 Rust 구조체 벡터로 직렬화/역직렬화됨.

### 3. 타입 불일치 사전 방어 (Proactive Casting)
- **배경**: Phase 3-1에서 겪었던 `INT4`(DB) vs `i64`(Rust) 런타임 에러(500) 경험.
- **조치**: 상세 조회 쿼리 작성 시 처음부터 `v.video_id::bigint` 캐스팅을 적용.
- **결과**: 타입 에러 없이 한 번에 통과.

### 4. 문서 서식 이슈 (Meta Issue)
- **이슈**: 프롬프트 작성 시 마크다운 코드 블록(` ``` `) 내부에 또 다른 코드 블록을 넣을 때 렌더링이 깨지는 현상 발생.
- **해결**: 외부 래핑을 위해 4개의 백틱(` ```` `)을 사용하거나, 문서 전달 시 파싱 구조 유의.

---

## 🔑 확립된 핵심 개발 패턴 (Key Patterns)

### 1. NotFound 처리의 표준화
- **Logic**: Repo 계층에서는 `Option<T>`를 반환하고, Service 계층에서 이를 검사(`ok_or`)하여 `AppError::NotFound`로 변환.
- **장점**: Repo는 데이터 접근에만 집중하고, 비즈니스 예외 처리는 Service가 담당하는 역할 분리(SoC) 실현.

### 2. 복합 객체 조회 (Join + Aggregation)
- **Pattern**: `LEFT JOIN`으로 연관 데이터를 붙이고 `GROUP BY`와 집계 함수로 메인 객체 하나에 종속 데이터를 말아 넣는 방식. N+1 문제를 근본적으로 해결하는 조회 패턴으로 확정.

---

## ✅ 결론
- **구현 완료**: `GET /videos/1` 호출 시 비디오 메타 정보와 태그 배열이 포함된 JSON 응답 확인.
- **안정성**: 존재하지 않는 ID 호출 시 404 응답 확인 완료.
- **다음 단계**: 사용자의 시청 기록을 추적하는 **Phase 3-3 (비디오 진행률 저장/조회)** 구현 진입.