# 📝 Dev Notes: Phase 3-1 Implementation (GET /videos)

## 📋 개요
- **작업**: 비디오 목록 조회 API (`GET /videos`) 및 데이터 시딩
- **기간**: 2025.12.31
- **성격**: List View, Complex SQL Join, Data Seeding, Type Casting

---

## 🛠️ 트러블슈팅 (Troubleshooting)

### 1. 스키마 오해와 SSoT 재확인 (Critical Schema Mismatch)
- **증상**: 관성적으로 `video` 테이블에 `title`, `thumbnail` 컬럼이 있을 것이라 가정하고 구현을 시도함.
- **원인**: **SSoT(Single Source of Truth)** 확인 소홀. 현재 아키텍처는 비디오의 메타 정보(제목, 설명 등)를 `video` 테이블이 아닌 **`video_tag`** 시스템으로 완전히 분리하여 관리함.
- **해결**:
  - `video` 테이블 단독 조회가 아닌, `video_tag_map` 및 `video_tag` 테이블과의 **LEFT JOIN**으로 전략 수정.
  - DTO에서 `title` 필드를 제거하고, `tags: Vec<String>` 필드로 대체하여 태그 목록을 반환하도록 변경.

### 2. 데이터 시딩 제약 조건 위반 (Data Seeding Errors)
- **이슈 1 (Unique Constraint)**: `video_tag_key`에 중복된 값(`basic-sentence-900` 등)을 반복 입력하여 `duplicate key value` 에러 발생.
  - -> **해결**: 키 값에 순번(`-01`, `-02`)을 붙여 고유성 보장.
- **이슈 2 (Type Mismatch in Insert)**: `updated_by_user_id` 컬럼(BigInt)에 이메일 문자열(`'kkr@kkr'`)을 입력 시도.
  - -> **해결**: 유효한 사용자 ID 정수값(`6`)으로 변경.

### 3. SQLx 런타임 타입 불일치 (Type Mismatch: INT4 vs i64)
- **증상**: API 호출 시 500 에러 발생.
  - `mismatched types; Rust type i64 (as SQL type INT8) is not compatible with SQL type INT4`
- **원인**: PostgreSQL의 `video_id`는 `INT` (4바이트, INT4)인 반면, Rust의 `VideoInfo` 구조체는 `i64` (8바이트)를 기대함. `sqlx`는 데이터 손실 방지를 위해 엄격한 타입 검사를 수행함.
- **해결**: SQL 쿼리 내에서 `video.video_id::bigint`로 **명시적 형변환(Casting)**을 수행하여 Rust 타입과 일치시킴.

---

## 🔑 확립된 핵심 개발 패턴 (Key Patterns)

### 1. SQL Aggregation for Meta Data
- **패턴**: `array_agg(vt.tag_name)` + `GROUP BY`
- **설명**: 1:N 관계인 태그 데이터를 애플리케이션 레벨에서 루프를 돌며 합치는 것이 아니라, DB 레벨에서 배열로 집계하여 가져옴으로써 성능 최적화 및 N+1 문제 원천 차단.

### 2. Validation & Pagination
- **패턴**: `validator` 크레이트를 활용한 선언적 검증.
- **설명**: 페이지 번호(`min=1`)나 개수(`range=1..100`) 등의 제약 조건을 DTO에 명시하고, 위반 시 422 에러로 처리하여 입력값 방어 로직 표준화.

---

## ✅ 결론
- **구현 완료**: 실제 Vimeo URL과 태그 데이터가 포함된 목록 조회 API 정상 동작 확인.
- **데이터 검증**: 태그 시스템을 통한 메타 데이터 조회 구조가 유효함을 입증.
- **다음 단계**: 목록에서 얻은 `video_id`를 이용한 **Phase 3-2 (비디오 상세 조회)** 구현 진행.