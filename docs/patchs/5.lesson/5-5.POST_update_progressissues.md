# 📝 Phase 5-5 회고 및 트러블슈팅 로그

이번 Phase는 데이터베이스의 **UPSERT(Insert or Update)** 패턴을 활용하여 클라이언트의 데이터 동기화 요청을 안정적이고 효율적으로 처리하는 데 집중했습니다.

## 1. 데이터베이스 및 아키텍처 (DB & Architecture)

### ✅ UPSERT 패턴 적용 (Atomic Operation)
* **상황:** 사용자의 진행도 갱신 요청은 "처음 시작(Insert)"일 수도 있고 "이어 하기(Update)"일 수도 있음. 이를 애플리케이션 레벨에서 `SELECT` -> `IF exist UPDATE ELSE INSERT`로 처리하면 **Race Condition(경쟁 상태)** 발생 위험이 있음.
* **해결:** PostgreSQL의 `INSERT ... ON CONFLICT (pk) DO UPDATE` 구문을 사용.
* **성과:** 쿼리 한 번으로 원자성(Atomicity)을 보장하며, 동시성 문제 없이 항상 최신 상태로 데이터를 갱신함.

### ✅ RESTful 리소스 설계
* **구현:** 동일한 URL 경로(`/lessons/{id}/progress`)에 대해 HTTP Method(`GET`, `POST`)만 다르게 하여 핸들러를 매핑.
  ```rust
  .route("/{id}/progress", get(handler::get_lesson_progress).post(handler::update_lesson_progress))
  ```
* **효과:** API 구조의 일관성을 유지하고 라우터 코드의 가독성을 높임.

## 2. 도메인 로직 및 에러 처리 (Domain Logic)

### ✅ 엄격한 유효성 검사 (422 Unprocessable Entity)
* **로직:** `percent`가 0~100 범위를 벗어나거나 `last_seq`가 음수인 경우.
* **처리:** `400 Bad Request`(형식 오류)가 아닌 `422 Unprocessable Entity`(문법은 맞으나 내용이 처리 불가능)로 응답.
* **의의:** 클라이언트 개발자에게 "JSON 형식이 틀린 게 아니라, 비즈니스 규칙을 위반했다"는 의미를 명확히 전달.

### ✅ 응답 전략 (200 vs 204)
* **결정:** 갱신 성공 후 `204 No Content` 대신 **`200 OK`와 갱신된 데이터 스냅샷**을 반환.
* **이유:** 클라이언트(프론트엔드)가 서버에 저장된 정확한 최종 상태(`updated_at` 등)를 즉시 UI에 반영할 수 있도록 하여, 별도의 GET 요청을 줄임.

## 3. 총평 (Conclusion)
* **완료:** Lesson 도메인의 핵심 기능(CRUD + Progress)이 모두 완성됨.
* **준비:** 이제 일반 사용자(User) 기능은 완성되었으므로, 관리자(Admin) 기능을 통해 이 데이터를 관리할 준비가 됨.