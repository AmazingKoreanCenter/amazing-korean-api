# 📝 Dev Notes: Phase 2-2 Implementation (POST /auth/logout)

## 📋 개요
- **작업**: 로그아웃 API (`POST /auth/logout`)
- **기간**: 2025.12.30
- **성격**: JWT 구조 변경(`session_id` 포함), 영구 세션 만료 처리, 트랜잭션 로깅

---

## 🛠️ 주요 변경 및 해결 (Refinements)

### 1. JWT Claims 구조 변경 (Session Identification)
- **상황**: 기존 `Claims`에는 `sub`(user_id)만 있어, 로그아웃 요청 시 **어떤 기기/세션**을 종료해야 하는지 식별하기 어려웠음.
- **해결**: `Claims` 구조체에 `session_id: String` 필드를 추가.
- **영향**:
  - `create_token` 함수의 시그니처가 변경됨 (`user_id` -> `user_id, session_id`).
  - 이에 따라 `auth/service.rs`뿐만 아니라 `user/service.rs`(회원가입)의 토큰 발급 로직도 함께 수정됨.
- **교훈**: JWT는 단순 인증 수단을 넘어, **세션의 식별자(Identifier)** 역할을 겸할 때 관리가 훨씬 용이해짐.

### 2. 로그아웃 트랜잭션 순서 (Consistency)
- **상황**: DB(`login` 테이블)와 Redis(캐시) 양쪽의 데이터를 지워야 함.
- **해결**: **DB 우선 정책 (Database First)**
  1. **DB Transaction**: `login` 상태를 `logged_out`으로 변경 + `login_log` 기록. (실패 시 롤백)
  2. **Redis Cleanup**: 트랜잭션 커밋 성공 후에만 Redis 키 삭제.
- **이유**: Redis는 휘발성이므로, 영구 저장소인 DB의 상태(SSOT)를 먼저 확정 짓는 것이 데이터 정합성에 유리함.

---

## 🔑 확립된 핵심 개발 패턴 (Key Patterns)

### 1. AuthUser Extractor의 진화
- **패턴**: 인증된 사용자의 정보 추출.
- **변경**: 기존에는 `user_id`만 꺼냈으나, 이제는 `session_id`도 함께 추출하여 핸들러에 전달.
- **코드**:
  ```rust
  pub struct AuthUser {
      pub sub: i64,
      pub session_id: String, // Added
  }
  ```

### 2. 상태 코드 204 (No Content)
- **패턴**: 로그아웃 성공 응답.
- **결정**: 로그아웃은 클라이언트에게 돌려줄 데이터가 없으므로 `200 OK`보다는 `204 No Content`가 의미론적으로 더 적합함.

---

## ✅ 결론
- **세션 수명주기 관리 완성**: 로그인(생성) -> 활동(검증) -> 로그아웃(만료)의 사이클이 DB와 Redis 양쪽에서 완벽하게 동기화됨.
- **다음 단계**: 만료된 Access Token을 심폐소생술 하는 **토큰 갱신(Refresh Token)** 기능 구현으로 이동.