# 📝 Dev Notes: Phase 2-1 Implementation (POST /auth/login)

## 📋 개요
- **작업**: 로그인 API (`POST /auth/login`)
- **기간**: 2025.12.30
- **성격**: JWT 발급, 영구 세션 생성, 그리고 **보안성(Enumeration Safety)** 강화

---

## 🛡️ 핵심 보안 이슈 및 해결 (Security & Troubleshooting)

### 1. 계정 열거(User Enumeration) 및 타이밍 공격 방지
- **이슈**: 존재하지 않는 이메일로 로그인 시도 시 `User Not Found`를 즉시 반환하면, 해커가 응답 시간 차이를 이용해 "이 이메일은 가입되어 있구나"를 알아낼 수 있음.
- **해결**:
  - 유저가 DB에 없더라도 즉시 에러를 내지 않고, **`dummy_password_hash`를 사용하여 `verify_password` 로직을 강제로 수행**함.
  - 이를 통해 로그인 성공/실패, 존재/미존재 여부와 관계없이 **항상 일정한 응답 시간(Constant Time)**을 유지하도록 구현.
- **코드**:
  ```rust
  let parsed_hash = match &user_info {
      Some(user) => ...,
      None => Self::dummy_password_hash()?, // 가짜 해시 생성
  };
  // 실제 검증과 동일한 비용의 연산 수행
  let password_ok = Argon2::default().verify(...).is_ok();
  ```

### 2. 더미 해시 성능 최적화 (Optimization)
- **이슈**: 로그인 실패 시마다 매번 더미 해시를 새로 생성(`Argon2` 해싱)하면 서버 자원이 낭비됨.
- **해결**: `std::sync::OnceLock`을 사용하여 **최초 1회만 더미 해시를 생성**하고, 이후에는 메모리에 캐싱된 값을 재사용.
- **효과**: 보안은 유지하면서 불필요한 CPU 연산을 제거함.

---

## 🔑 확립된 핵심 개발 패턴 (Key Patterns)

### 1. 검증 순서의 중요성 (Verification Order)
- **패턴**: `User Lookup` -> `Password Check` -> `User State Check`
- **이유**: `User State`(활성/차단 여부)를 비밀번호 검증보다 먼저 체크하면, 차단된 계정임을 즉시 알리게 되어 계정 존재 여부가 노출됨. 반드시 **자격 증명(ID/PW)이 확실한 사용자에게만** 구체적인 상태 에러(403)를 반환해야 함.

### 2. 트랜잭션 기반 세션 생성
- **패턴**: `Login Table Insert` + `Log Table Insert` Atomicity.
- **구현**: 세션 발급(로그인 성공)과 감사 로그(Audit Log) 기록은 반드시 동시에 성공하거나 실패해야 데이터 정합성이 유지됨.

---

## ✅ 결론
- **보안 표준 준수**: OWASP 등에서 권장하는 'Time-based Enumeration' 방어 로직이 적용됨.
- **인증 파이프라인 완성**: 이제 발급된 `Access Token`을 통해 앞서 만든 `Phase 1` API들을 실제로 호출할 수 있게 됨.
- **다음 단계**: 토큰 갱신(Refresh) 및 로그아웃(Logout) 구현으로 세션 수명주기 관리 완성.