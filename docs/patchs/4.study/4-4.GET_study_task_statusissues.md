# 📝 Phase 4-4 회고 및 트러블슈팅 로그

이번 Phase는 명확한 명세서 파일(`.md`)이 주어졌을 때 AI(Codex)가 얼마나 정확하게 코드를 구현할 수 있는지 증명된 사례입니다. 또한, 개발자와 AI 간의 협업 프로토콜(SOP)을 확정한 중요한 단계였습니다.

## 1. 기술적 성과 및 모범 사례 (Technical Best Practices)

### ✅ SQL 집계(Aggregation) 최적화
* **상황:** 사용자의 학습 기록(시도 횟수, 정답 여부, 최고 점수)을 각각 조회하면 DB 부하가 발생함.
* **해결:** `GROUP BY`와 집계 함수를 사용하여 단 한 번의 쿼리로 통계 데이터 산출.
* **핵심 쿼리:**
  ```sql
  SELECT
    COUNT(*) as attempts,
    BOOL_OR(study_task_is_correct_log) as is_solved, -- 하나라도 정답이면 true
    MAX(study_task_score_log) as best_score          -- 최고 점수 추출
  FROM study_task_log ...
  ```

### ✅ Null Safety & Default Handling (Rust `Option` 처리)
* **상황:** 사용자가 문제를 한 번도 풀지 않은 경우(Empty State), SQL 집계 결과가 `NULL`로 반환됨.
* **해결:** Rust Service 계층에서 `unwrap_or`를 사용하여 클라이언트 친화적인 기본값(`0`, `false`)으로 변환.
  ```rust
  // Service Layer
  let is_solved = stats.is_solved.unwrap_or(false);
  let best_score = stats.best_score.unwrap_or(0);
  ```

### ✅ 로그 필터링 정확성
* **성과:** 명세서에 명시하지 않았음에도, AI가 `StudyTaskLogAction::Answer` 조건을 스스로 추가하여 '단순 조회 로그'와 '정답 제출 로그'를 정확히 구분함.

---

## 2. 프로세스 및 협업 이슈 (Process Issues)

### 🔴 이슈: AI의 SOP 미준수 (Context Reset)
* **문제:** AI가 이전 Phase에서 합의된 "간결한 실행 방식(파일+명령)"을 망각하고, 불필요하게 긴 설명과 중복된 프롬프트를 제시하여 작업 효율 저하.
* **원인:** 새로운 Phase 진입 시 AI의 작업 방식 컨텍스트가 초기화되는 현상.
* **해결:** **[AMK API 5단계 표준 작업 절차(SOP)]** 공식 확정 및 `LLM_PATCHS_TEMPLATE.md` 업데이트.
  1. Spec Check (스펙 확인)
  2. Generate Prompt File (명세서 파일 생성)
  3. Trigger Prompt (실행 명령 전달)
  4. Verification (검증)
  5. **Retrospective (회고 및 로그 정리 - 현재 단계)**

---

## 🛠️ 트러블슈팅 및 주요 기술적 의사결정 (Troubleshooting & Decisions)

### 1. Nullable 컬럼 매핑 에러 (Decoding Error: Unexpected Null)
- **증상**: `study_task_status` 테이블의 `last_attempt_at` 컬럼은 NULL이 허용되지만, Rust 구조체에서 `DateTime<Utc>`로 정의하여 디코딩 시 런타임 에러 발생.
  - *Error: `error occurred while decoding column 2: unexpected null; try decoding as an Option`*
- **원인**: SQLx는 DB 컬럼이 NULL일 수 있다면 Rust 타입도 반드시 `Option<T>`여야 함을 강제함.
- **해결**:
  - **DTO**: `last_attempt_at: Option<DateTime<Utc>>`로 수정.
  - **SQL Query**: `study_task_status_last_attempt_at AS "last_attempt_at?"` 문법(물음표 `?`)을 사용하여 SQLx 매크로에게 Nullable임을 명시.

### 2. 빈 상태(Empty State) 처리 전략
- **과제**: 사용자가 문항을 푼 적이 없어 `study_task_status` 테이블에 레코드가 없는 경우 404를 반환할지, 기본값을 반환할지 결정 필요.
- **결정**: **기본값 반환 (200 OK)**.
  - 프론트엔드 입장에서 "아직 안 풀었음"은 에러 상황이 아니라 유효한 상태임.
  - **구현**:
    1. `repo.find_task_status`가 `Option<TaskStatusRes>`를 반환.
    2. Service 계층에서 `None`일 경우 `try_count: 0`, `is_solved: false`, `last_attempt_at: None`으로 채워진 기본 구조체 생성하여 반환.

### 3. 존재하지 않는 문항 식별 (Distinguish Missing Task vs Missing Status)
- **문제**: 단순히 `find_task_status` 결과가 없다고 해서 기본값을 반환하면, 실제로 존재하지 않는 `task_id`(예: 99999)에 대해서도 200 OK(빈 상태)를 주는 논리적 오류 발생.
- **해결**: **2단계 조회**.
  1. `repo.exists_task(task_id)`: 문항 자체가 존재하는지 확인 -> 없으면 **404 Not Found**.
  2. `repo.find_task_status(...)`: 문항이 있다면 상태 조회 -> 없으면 **기본값(200 OK)**.

### 4. 상태 조회 로깅 (View Logging for Status)
- **정책**: `status` API 호출도 사용자의 학습 행위의 일부로 간주하여 `STUDY_TASK_LOG`에 기록.
- **구현**:
  - `action='status'` (Enum: `StudyTaskLogAction::Status`) 사용.
  - 로깅 실패(`log_task_action` 에러) 시 메인 비즈니스 로직(조회)을 중단하지 않고 `warn!` 로그만 남기고 무시(Fire-and-forget). 이는 조회 기능의 가용성을 우선시한 결정.

### 5. 필드 명세 동기화 (Spec Compliance)
- **변경**: 기존 `TaskStatusRes`의 필드(`attempts`, `last_score`)를 스키마 및 최신 스펙(`try_count`, `last_attempt_at`)에 맞춰 재정의.
- **효과**: 프론트엔드와 백엔드 간의 용어 불일치 해소.

---

## 3. 총평 (Conclusion)
* **코드 품질:** 별도의 수정 없이 **One-Shot Success** (컴파일 에러 및 로직 에러 0건).
* **교훈:** "잘 작성된 프롬프트 파일 하나가 열 마디 설명보다 낫다."