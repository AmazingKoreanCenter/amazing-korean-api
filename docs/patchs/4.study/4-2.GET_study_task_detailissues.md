# 📝 Dev Notes: Phase 4-2 Implementation (GET /studies/tasks/{id})

## 📋 개요
- **작업**: 학습 문제 상세 조회 API (`GET /studies/tasks/{id}`)
- **기간**: 2026.01.02
- **성격**: Polymorphic Data Handling, Join Query, Security (Field Exclusion)

---

## 🛠️ 트러블슈팅 (Troubleshooting)

### 1. 정답 데이터 보안 (Security: Answer Masking)
- **과제**: `STUDY_TASK_CHOICE`, `_TYPING`, `_VOICE` 테이블에는 정답 컬럼(`_answer`, `_correct`)이 포함되어 있음. 클라이언트에는 문제 풀이 전 단계이므로 절대 정답을 노출하면 안 됨.
- **위험**: `SELECT *`를 사용하거나 DTO 매핑 실수가 발생하면 정답이 JSON에 포함되어 유출될 수 있음.
- **해결**:
  - **SQL Level**: 쿼리 작성 시 필요한 컬럼(지문, 보기, 미디어 URL 등)만 명시적으로 나열(`SELECT`)하여 정답 컬럼을 원천 배제.
  - **DTO Level**: Payload 구조체 정의 시 정답 필드를 아예 정의하지 않음으로써, 실수로 데이터가 들어오더라도 직렬화되지 않도록 이중 안전장치 마련.

### 2. 다형성 응답 구조 처리 (Polymorphic Payload)
- **과제**: 문제 유형(`kind`: 객관식, 주관식, 발음)에 따라 `payload` 필드의 내부 구조가 완전히 다름.
- **해결**: Rust의 Enum과 Serde의 `untagged` 기능 활용.
  - `#[serde(untagged)]` 속성을 가진 `TaskPayload` Enum 정의.
  - JSON 직렬화 시 불필요한 태그 없이 내용물(`Variant`)의 필드만 평탄하게 출력됨.
  - 예: 객관식은 `choice_1~4` 필드가 있고, 주관식은 없음.

### 3. 조건부 로깅 전략 (Conditional Logging)
- **과제**: 해당 API는 비로그인(Guest) 상태에서도 호출 가능하지만, 로그인한 유저(`AuthUser`)가 조회했을 때는 `STUDY_TASK_LOG`에 '조회(`view`)' 이력을 남겨야 함.
- **해결**:
  - **Handler**: `OptionalAuth` 추출기를 사용하여 유저 정보를 `Option<AuthUser>` 형태로 Service에 전달.
  - **Service**:
    1. 문제 데이터 조회 (공통).
    2. `if let Some(user) = auth_user` 블록 내에서 로깅 로직(`repo.log_task_view`) 실행.
    3. 로깅 실패가 메인 조회 로직(200 OK)을 방해하지 않도록 에러는 로그로만 남기고 무시(Non-blocking/Fire-and-forget 지향).

### 4. DB 조인 전략 (Join vs Multiple Queries)
- **과제**: 부모 테이블(`STUDY_TASK`)과 3개의 자식 테이블 중 하나를 조인해야 함.
- **옵션**:
  1. `LEFT JOIN` 3개를 모두 걸어서 한 번에 조회. (컬럼 많음, NULL 많음)
  2. `kind`를 먼저 조회하고, 맞는 테이블만 2차 조회. (쿼리 2번)
- **결정**: 단일 건 조회이므로 **옵션 1 (LEFT JOIN)** 채택.
  - DB Round-trip 비용을 줄이고, 정합성을 보장하기 위함.
  - `COALESCE` 등을 활용하여 불필요한 NULL 처리를 간소화.

### 5. 엄격한 타입 매핑 (Strict Type Compliance)
- **규칙**: `AMK_SCHEMA_PATCHED.md` 및 `AMK_BACKEND_STRICT_MODE` 준수.
- **적용**:
  - `study_task.updated_by_user_id` (BIGINT) -> Rust `i64`.
  - API Response의 ID 필드 -> 프론트엔드 호환성을 위해 `i32` (또는 `u32`)로 변환하여 전달.

### 6. ORM 매핑 트러블슈팅 (SQLx Decoding Strategy)
- **과제**: `LEFT JOIN`으로 다형성 테이블(`choice`, `typing`, `voice`)을 통합 조회할 때 발생하는 Nullability 불일치 문제 해결.
- **현상**: DB 스키마상 `NOT NULL`로 정의된 컬럼이라도 `LEFT JOIN` 결과로는 `NULL`이 반환될 수 있음. 그러나 SQLx `query_as!` 매크로는 스키마 정의만 보고 이를 `NOT NULL` 타입으로 추론하여 "unexpected null" 에러 발생.
- **해결**:
  - **Override Syntax**: 쿼리 작성 시 Alias 뒤에 `?`를 붙이는 문법(`column as "field?"`)을 사용하여, SQLx에게 강제로 `Option` 타입으로 디코딩할 것을 명시.
  - **Struct Consistency**: DB Row를 매핑하는 구조체의 필드를 모두 `Option<T>`로 선언하여, 데이터가 없는(Join 실패) 경우를 안전하게 `None`으로 처리하도록 구현.

---

## 🔑 주요 기술적 의사결정 (Key Decisions)

### 1. 다형성(Polymorphism) 처리
- **구현**: `TaskPayload` Enum에 `#[serde(untagged)]`를 적용.
- **효과**: 클라이언트는 `kind` 필드를 보고 `payload` 내부 구조(`choice_1` vs `image_url` 등)를 추론할 수 있으며, 불필요한 중첩 태그 없이 깔끔한 JSON 응답 제공.

### 2. 정답 보안 (Security by Projection)
- **전략**: 문제 풀이 전 단계이므로, DB 조회 시점부터 **정답 컬럼(`correct`, `answer`)을 제외**하고 조회.
- **구현**: `SELECT *` 대신 필요한 컬럼만 명시적으로 나열하여 매핑. API 응답 DTO에도 정답 필드를 원천적으로 포함하지 않음.

### 3. 효율적인 쿼리 (One-Shot Query)
- **전략**: `STUDY_TASK`를 기준으로 3개의 상세 테이블(`CHOICE`, `TYPING`, `VOICE`)을 모두 `LEFT JOIN`하여 한 번의 DB 요청으로 데이터를 완성.

---

## ✅ 결론
- **구현 완료**: 문제 유형별(`choice`, `typing`, `voice`)로 서로 다른 Payload 구조가 정상적으로 조회됨.
- **테스트 통과**:
  - 유효한 ID 조회 시 200 OK 및 유형별 데이터 확인.
  - 존재하지 않는 ID 조회 시 404 Not Found 확인.
- **다음 단계**: 사용자가 문제를 풀고 정답을 제출하는 **Phase 4-3 (정답 제출 및 채점)** 구현 진입.