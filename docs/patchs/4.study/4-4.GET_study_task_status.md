# PATCH — Phase 4-4 Study Task Status (GET /studies/tasks/{id}/status)

**ROLE**:
- 당신은 Amazing Korean 프로젝트의 **"지능형 구현 전문가(Intelligent Implementation Specialist)"**입니다.
- **Tech Stack**: Rust, Axum 0.8, SQLx 0.7+, Utoipa 5, PostgreSQL.

**OBJECTIVE**:
- **Phase 4-4 `GET /studies/tasks/{id}/status`** 엔드포인트를 구현하십시오.
- **Critical Fix**: 현재 `"unexpected null"` 디코딩 에러가 발생하고 있습니다. `last_attempt_at`과 같은 Nullable 컬럼은 반드시 Rust의 `Option<T>` 타입으로 매핑하여 에러를 방지하십시오.
- **Logic**: 사용자의 문제 풀이 현황을 조회하고, 로그를 남깁니다.

**CONTEXT (SSOT & Rules)**:
1.  **Schema (`study_task_status`)**:
    - `user_id` (`BIGINT` -> `i64`)
    - `study_task_id` (`INT` -> `i32`)
    - `study_task_status_try_count` (`INT` -> `i32`)
    - `study_task_status_is_solved` (`BOOLEAN` -> `bool`)
    - `study_task_status_last_attempt_at` (`TIMESTAMPTZ` -> **`Option<DateTime<Utc>>`**)
2.  **Spec 5.4-4 (Logic)**:
    - **Success (200)**:
      - 데이터가 있으면: 해당 데이터를 반환.
      - 데이터가 없으면(아직 안 품): **기본값 반환** (`try_count=0`, `is_solved=false`, `last_attempt_at=null`). **404 에러 아님.**
    - **Error (404)**: `study_task` 테이블에 해당 `task_id` 자체가 없을 경우.
    - **Logging**: 조회 성공 시 `STUDY_TASK_LOG`에 `action='status'`로 로그 저장.

**CONTRACT (API Specification)**:

### Request: `GET /studies/tasks/{id}/status`
- **Path**: `id` (`i32`)
- **Headers**: `Authorization: Bearer ...` (Required)

### Response: `200 OK` (`TaskStatusRes`)
```json
{
  "try_count": 0,          // i32
  "is_solved": false,      // bool
  "last_attempt_at": null  // Option<String> (ISO8601)
}
```

**IMPLEMENTATION STEPS**:

1.  **DTO Setup (`src/api/study/dto.rs`)**:
    - `TaskStatusRes` 구조체를 정의합니다.
    - **핵심**: `last_attempt_at` 필드에 `Option`을 사용하여 Null Decoding Error를 방지하십시오.

2.  **Repository (`src/api/study/repo.rs`)**:
    - 함수 1: `exists_task(task_id: i32) -> Result<bool>` (문항 존재 여부 확인).
    - 함수 2: `find_task_status(user_id: i64, task_id: i32) -> Result<Option<TaskStatusRes>>`.
      - `sqlx::query_as!`를 사용할 때 `study_task_status_last_attempt_at` 컬럼을 `Option`으로 받도록 주의하십시오.
    - 함수 3: `log_task_status_view(...)` (이미 구현된 로그 함수가 있다면 재사용, 없다면 `action='status'`로 insert).

3.  **Service (`src/api/study/service.rs`)**:
    - 함수: `get_task_status(auth_user: AuthUser, task_id: i32)`.
    - **Step 1**: `repo.exists_task(task_id)` 확인 -> False면 `AppError::NotFound`.
    - **Step 2**: `repo.find_task_status(...)` 호출.
    - **Step 3**: 결과가 `None`이면 Default Struct(`try_count: 0, ...`) 생성.
    - **Step 4**: 로그 저장 (`repo.log_task_action(..., 'status')`).
    - **Step 5**: 결과 반환.

4.  **Handler (`src/api/study/handler.rs`)**:
    - 함수: `get_task_status_handler`.
    - `AuthUser` 필수.

5.  **Router (`src/api/study/router.rs`)**:
    - Route: `.route("/tasks/{id}/status", get(handler::get_task_status_handler))`.

**FILE PATCHES**:
- `src/api/study/dto.rs` (Update)
- `src/api/study/repo.rs` (Update)
- `src/api/study/service.rs` (Update)
- `src/api/study/handler.rs` (Update)
- `src/api/study/router.rs` (Update)

**cURL SMOKE TEST**:
```bash
# 1. 시도 기록이 없는 문항 조회 (200 OK, default values)
curl -X GET "http://localhost:3000/api/studies/tasks/105/status" \
     -H "Authorization: Bearer <TOKEN>"

# 2. 존재하지 않는 문항 조회 (404 Not Found)
curl -X GET "http://localhost:3000/api/studies/tasks/99999/status" \
     -H "Authorization: Bearer <TOKEN>" -v
```