# 📝 Phase 4-3 이슈 회고 및 트러블슈팅 로그

이번 Phase 4-3에서는 로컬 개발 환경(Windows/WSL2/Docker) 설정과 Rust 웹 서버의 데이터 처리(JSON/UUID) 과정에서 발생한 다양한 이슈를 해결했습니다. 주요 내용과 해결책을 정리합니다.

---

## 1. Rust 컴파일 및 의존성 이슈

### 🔴 이슈: `Uuid` 타입 미지원 에러 (Trait Bound Not Satisfied)
`sqlx`를 사용하여 DB에 `Uuid` 타입을 저장하거나 조회하려고 할 때 컴파일 에러가 발생했습니다.

* **에러 메시지:**
  ```text
  error[E0277]: the trait bound `Uuid: sqlx::Encode<'_, _>` is not satisfied
  ```
* **원인:** `sqlx` 크레이트는 기본적으로 UUID 타입을 지원하지 않으며, `features` 플래그를 통해 명시적으로 활성화해야 합니다.
* **해결:** `Cargo.toml` 수정
  ```toml
  # Cargo.toml
  [dependencies]
  sqlx = { version = "0.8", features = ["runtime-tokio-native-tls", "postgres", "uuid"] }
  ```

### 🟠 이슈: 사용하지 않는 필드 경고 (Unused Fields)
아직 구현되지 않은 로직(AI 발음 평가 등)을 위해 선언해 둔 구조체 필드 때문에 컴파일러 경고가 발생했습니다.

* **에러 메시지:** `warning: fields task_id and voice_answer are never read`
* **해결:** 구조체 위에 `#[allow(dead_code)]` 속성을 추가하여 경고 무시.

---

## 2. 개발 환경 및 인프라 (Docker & Windows WSL2)

가장 시간이 많이 소요되었던 부분으로, Windows의 포트 예약 정책과 Docker 네트워킹 충돌이 주원인이었습니다.

### 🔴 이슈: Redis 연결 실패 (HTTP 500 / Connection Refused)
API 서버 실행 시 Redis에 접속하지 못해 에러가 발생했습니다.

* **에러 메시지:**
  ```text
  Error occurred while creating a new object: Connection refused (os error 111)
  ```
* **원인 1:** `.env` 설정 오류. 호스트(Local)에서 실행 중인 앱이 Docker 내부 컨테이너 이름(`amk-redis`)으로 접속을 시도함.
* **해결 1:** 호스트 주소인 `127.0.0.1`로 변경.
* **원인 2:** Docker 컨테이너 실행 시 포트 포워딩(`-p`) 옵션 누락.
* **해결 2:** `docker run` 명령어에 `-p` 옵션 추가.

### 🔴 이슈: Windows 포트 예약 충돌 (Ports are not available)
Redis 포트(6379)를 열려고 하자, 이미 사용 중이라며 Docker가 실행되지 않았습니다. `netstat`으로도 확인되지 않는 유령 포트였습니다.

* **에러 메시지:**
  ```text
  docker: Error response from daemon: ports are not available: exposing port ...
  ```
* **분석:** Windows 명령어 `netsh interface ipv4 show excludedportrange protocol=tcp` 실행 결과, `6329 ~ 6428` 범위가 시스템(Hyper-V 등)에 의해 예약되어 있음을 확인.
* **해결:** 예약된 범위를 벗어난 **16379 포트**를 사용하여 우회.
  ```bash
  # Docker 실행 (호스트 16379 -> 컨테이너 6379)
  docker run -d --name amk-redis -p 16379:6379 redis:7

  # .env 수정
  REDIS_URL=redis://127.0.0.1:16379
  ```

---

## 3. API 요청 및 데이터 처리 이슈

### 🟠 이슈: JWT 토큰 만료 (401 Unauthorized)
테스트 도중 유효한 토큰임에도 불구하고 인증 에러가 발생했습니다.

* **에러 메시지:** `{"message": "Invalid token", "http_status": 401}`
* **원인:** 환경 설정 트러블슈팅이 길어지면서, 발급받았던 Access Token의 유효 시간(15분)이 경과함.
* **해결:** 로그인 API(`POST /auth/login`)를 재호출하여 새로운 토큰 발급.

### 🟠 이슈: JSON 역직렬화 실패 (422 Unprocessable Entity)
문제 정답 제출 시, Body 형식이 맞지 않아 에러가 발생했습니다.

* **에러 메시지:**
  ```text
  Failed to deserialize... expected struct variant SubmitAnswerReq::Typing
  ```
* **원인 1:** 문제 유형 불일치. (객관식 답안 형식을 주관식 문제 ID로 제출함)
* **원인 2:** JSON 구조 오류. Rust의 Enum Variant가 구조체(`struct`)를 포함할 경우, JSON도 **중첩 객체** 형태여야 함.
* **해결:**
  * **잘못된 요청:** `{"typing": "가"}`
  * **올바른 요청:**
    ```json
    {
      "typing": {
        "text": "가"
      }
    }
    ```

---

## 🛠️ 트러블슈팅 및 주요 기술적 의사결정 (Troubleshooting & Decisions)

### 1. AuthUser 추출기 타입 불일치 (Type Mismatch: AuthUser vs Claims)
- **증상**: 핸들러에서 `AuthUser(auth_user)`로 패턴 매칭을 시도하거나, 서비스 계층에서 `auth_user.sub`로 접근 시 컴파일 에러 발생.
  - *Error: `expected AuthUser, found Claims`*
  - *Error: `no field session_id on type AuthUser`*
- **원인**: `AuthUser`는 `Claims`를 감싸고 있는 **Tuple Struct**(`pub struct AuthUser(pub Claims)`)임. 내부 필드에 직접 접근할 수 없음.
- **해결**:
  - **Handler**: 인자에서 패턴 매칭을 하지 않고 `auth_user: AuthUser` 그대로 받음.
  - **Service**: `let AuthUser(claims) = auth_user;` 구문을 통해 내부 `Claims`를 명시적으로 구조 분해(Destructuring)하여 `claims.sub`, `claims.session_id`로 접근.

### 2. DTO 직렬화 트레이트 누락 (Missing Serialize Trait)
- **증상**: 채점 요청 데이터(`SubmitAnswerReq`)를 `STUDY_TASK_LOG`의 payload(JSONB)로 저장하려 할 때 컴파일 에러 발생.
  - *Error: `the trait bound SubmitAnswerReq: Serialize is not satisfied`*
- **원인**: DTO 정의 시 `#[derive(Deserialize)]`만 선언하고 `Serialize`를 누락함. `serde_json::to_value` 함수는 입력값의 `Serialize` 구현을 요구함.
- **해결**: `dto.rs`의 `SubmitAnswerReq`에 `Serialize` 매크로 추가.

### 3. 정답 키 조회 최적화 (Optimized Answer Key Lookup)
- **과제**: 채점을 위해 문제의 `kind`와 `answer`(정답)가 필요함. 기존에는 `task_detail`과 `explanation`을 각각 조회하는 비효율적인 방식이었음.
- **해결**: `find_answer_key` 레포지토리 함수 신설.
  - `CASE WHEN` 문을 사용하여 `kind`(`choice`, `typing`, `voice`)에 따라 흩어져 있는 정답 컬럼(`_choice_answer`, `_typing_answer` 등)을 하나의 `answer` 필드로 통합 조회.
  - 불필요한 조인을 줄이고 로직을 단순화함.

### 4. 트랜잭션 내 로그 무결성 보장 (Transactional Logging)
- **과제**: `STUDY_TASK_STATUS`(Upsert)와 `STUDY_TASK_LOG`(Insert)는 반드시 동시에 성공해야 함.
- **구현**: `submit_grade_tx` 함수 내에서 `sqlx::Transaction` 사용.
  - Status 업데이트 후 반환된 `try_count`를 Log에 즉시 반영.
  - **Login Session Join**: 로그 저장 시 `login` 테이블과 조인하여 현재 세션의 유효성을 재확인. 세션이 유효하지 않으면(조인 실패 시) 에러를 반환하여 데이터 무결성 강제.

### 5. 다형성 요청 처리 (Polymorphic Request DTO)
- **설계**: `SubmitAnswerReq`를 `untagged`가 아닌 **`tagged` Enum**(`#[serde(tag = "kind")]`)으로 변경.
  - 클라이언트가 명시적으로 `kind: "choice"` 등을 보내게 하여 파싱 모호성을 제거하고, API 문서 가독성 향상.

---

### ✅ 결론 및 배운 점
1. **Windows 포트 예약:** `netstat`에 안 보여도 `netsh`로 예약된 포트인지 확인해야 한다.
2. **도커 네트워킹:** WSL2와 Docker Desktop 간의 통신은 `localhost` 포트 포워딩이 가장 확실한 방법이다.
3. **Rust 데이터 모델:** Enum 내부에 Struct가 있다면, JSON 요청도 중첩 객체(`{ key: { inner: value } }`)로 보내야 한다.