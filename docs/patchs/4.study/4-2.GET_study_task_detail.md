# PATCH — Phase 4-2 Study Task Detail (GET /studies/tasks/{id})

**ROLE**:
- 당신은 Amazing Korean 프로젝트의 **"지능형 구현 전문가(Intelligent Implementation Specialist)"**입니다.
- `AMK_BACKEND_STRICT_MODE_PROTOCOL.md`와 `AMK_API_MASTER.md`의 규칙을 엄격히 준수합니다.
- **Tech Stack**: Rust, Axum 0.8, SQLx 0.7+, Utoipa 5, PostgreSQL.

**OBJECTIVE**:
- **Phase 4-2 `GET /studies/tasks/{id}`** 엔드포인트를 구현하십시오.
- `STUDY_TASK` 테이블과 하위 상세 테이블(`_CHOICE`, `_TYPING`, `_VOICE`)을 조인하여 문제 정보를 조회합니다.
- **Security**: 문제 풀이 전 단계이므로 **정답(Correct Answer) 정보는 절대 반환하지 마십시오.**
- **Logging**: 인증된 사용자가 요청한 경우, `STUDY_TASK_LOG`에 `view` 액션을 기록해야 합니다.

**CONTEXT (SSOT & Rules)**:
1.  **Schema & Relations**:
    - `study_task` (Parent): `study_task_id` (PK, INT -> `i32`), `updated_by_user_id` (BIGINT -> **`i64`**).
    - `study_task_kind` (ENUM): `choice`, `typing`, `voice`.
    - `study_task_choice` (Child): `study_task_choice_answer` (정답) 컬럼 존재 -> **반환 금지**.
    - `study_task_typing` (Child): `study_task_typing_answer` (정답) 컬럼 존재 -> **반환 금지**.
    - `study_task_voice` (Child): `study_task_voice_answer` (정답) 컬럼 존재 -> **반환 금지**.
2.  **Logic & Logging (Spec 5.4-2)**:
    - **Success (200)**: 데이터 존재 시 반환.
    - **Logging**: `AuthUser`가 존재하는 경우 `STUDY_TASK_LOG` 테이블에 `action='view'`로 로그를 저장(Insert)합니다. (Guest일 경우 로깅 생략).
    - **Error (404)**: 해당 `id`의 문제가 없으면 `AppError::NotFound` 반환.

**CONTRACT (API Specification)**:

### Request: `GET /studies/tasks/{id}`
- **Path Parameter**: `id` (`i32`)
- **Headers**: `Authorization` (Optional - `Bearer ...`)

### Response: `200 OK` (`StudyTaskDetailRes`)
```json
{
  "task_id": 101,          // i32
  "study_id": 1,           // i32
  "kind": "choice",        // Enum: choice | typing | voice
  "seq": 1,
  "created_at": "...",
  "payload": {             // Polymorphic (Untagged Enum)
    // Case 1: Kind = 'choice'
    "question": "Which one is apple?",
    "choice_1": "사과",
    "choice_2": "포도",
    "choice_3": "수박",
    "choice_4": "딸기",
    "audio_url": "...",
    "image_url": "..."
    // Note: 'answer' field IS REMOVED
  }
}
```

**IMPLEMENTATION STEPS**:

1.  **DTO Setup (`src/api/study/dto.rs`)**:
    - `StudyTaskKind` Enum 정의 (DB Enum 매핑).
    - `TaskPayload` Enum 정의 (`#[serde(untagged)]` 사용 권장).
      - `ChoicePayload`: `question`, `choice_1`~`4`, `audio_url`, `image_url`. (No Answer)
      - `TypingPayload`: `question`, `image_url`. (No Answer)
      - `VoicePayload`: `question`, `audio_url`, `image_url`. (No Answer)
    - `StudyTaskDetailRes` 구조체 정의.

2.  **Repository (`src/api/study/repo.rs`)**:
    - 함수 1: `find_task_detail(task_id: i32) -> Result<Option<StudyTaskDetailRes>>`.
      - `LEFT JOIN`을 사용하여 `task`와 3개의 서브 테이블을 한 번에 조회하거나, `kind`를 먼저 읽고 필요한 테이블만 조회하는 방식 중 효율적인 방법 선택.
      - **중요**: DB에서 데이터를 읽어올 때 `answer` 컬럼은 아예 `SELECT` 하지 않거나 DTO 매핑 시 제외하십시오.
    - 함수 2: `log_task_action(user_id: i64, task_id: i32, action: TaskLogAction)`.
      - `study_task_log` 테이블에 Insert.

3.  **Service (`src/api/study/service.rs`)**:
    - 함수: `get_task_detail(user: Option<AuthUser>, task_id: i32)`.
    - `repo.find_task_detail` 호출 -> 없으면 `AppError::NotFound`.
    - `user`가 `Some`이면 `repo.log_task_action(user.id, task_id, 'view')`를 **비동기적으로** 수행 (또는 await).

4.  **Handler (`src/api/study/handler.rs`)**:
    - 함수: `get_study_task_handler`.
    - Extractor: `Path(id): Path<i32>`, `OptionalAuth(user): OptionalAuth`. (Optional Auth 구현 필요 시 `Extension`이나 `Option<AuthUser>` 사용).

5.  **Router (`src/api/study/router.rs`)**:
    - Route: `.route("/tasks/{id}", get(handler::get_study_task_handler))`.

**FILE PATCHES**:
- `src/api/study/dto.rs` (Update)
- `src/api/study/repo.rs` (Update)
- `src/api/study/service.rs` (Update)
- `src/api/study/handler.rs` (Update)
- `src/api/study/router.rs` (Update)

**cURL SMOKE TEST**:
```bash
# Choice Task 조회 (No Auth)
curl -X GET "http://localhost:8080/api/studies/tasks/101"

# Typing Task 조회 (With Auth - Log Trigger)
curl -X GET "http://localhost:8080/api/studies/tasks/102" \
     -H "Authorization: Bearer <VALID_TOKEN>"
```