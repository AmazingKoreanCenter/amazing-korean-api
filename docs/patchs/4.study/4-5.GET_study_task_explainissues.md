# 📝 Phase 4-5 회고 및 트러블슈팅 로그

이번 단계는 기능 구현 자체보다 **"데이터베이스 스키마의 정확한 파악"**과 **"명명 규칙(Naming Convention)의 중요성"**을 재확인하는 과정이었습니다.

## 1. 협업 및 프로세스 이슈 (Process Issues)

### 🔴 이슈: AI의 스키마 추측 (Assumption vs Fact)
* **문제:** AI가 실제 테이블 정의(`STUDY_EXPLAIN`)를 확인하지 않고, 일반적인 관례나 이전 기억에 의존하여 잘못된 테이블명(`study_task_typing` 등)과 컬럼 타입(JSON Array)을 가정하여 쿼리를 작성함.
* **원인:** Context 내의 스키마 정의 파일을 능동적으로 참조하지 않고 안일하게 추론함.
* **해결:**
  1. 개발자가 올바른 DDL(`CREATE TABLE ...`)을 제공하여 데이터 구조 교정.
  2. 개발자의 주도로 프로젝트 일관성을 위해 테이블명을 `study_task_explain`으로 변경(`study_task_` prefix 통일).
  3. AI가 이를 명세서(`.md`)에 정확히 반영하여 Codex 실행.
* **교훈:** "AI는 쿼리를 짜기 전에 반드시 스키마 정의를 먼저 요청하거나 확인해야 한다."

## 2. 기술적 구현 포인트 (Technical Implementation)

### ✅ 403 vs 404 에러 분기 처리 (Security Logic)
* **로직:**
  1. **권한 체크:** 사용자가 문제를 푼 적이 있는가? (`has_attempted` = Answer Log 존재 여부) $\to$ 없으면 `403 Forbidden`.
  2. **데이터 체크:** 해설 데이터가 존재하는가? $\to$ 없으면 `404 Not Found`.
* **성과:** '볼 권한이 없는 것'과 '데이터가 없는 것'을 명확히 구분하여 클라이언트 및 보안 정책 준수.

### ✅ 데이터 타입 어댑터 (Type Adapting)
* **상황:** DB는 단일 URL 문자열(`TEXT`)을 저장하지만, API 명세(`TaskExplainRes`)는 리스트(`Vec<String>`) 반환을 요구함.
* **해결:** Rust의 `Option` 메서드 체이닝을 이용해 간결하고 안전하게 변환.
  ```rust
  // Service Layer: Option<String> -> Vec<String>
  let resources = explanation.explain_media_url
      .map(|url| vec![url]) // Some(url) -> Some(Vec[url])
      .unwrap_or_default(); // None -> [] (Empty List)
  ```

## 🛠️ 트러블슈팅 및 주요 기술적 의사결정 (Troubleshooting & Decisions)

### 1. 해설 열람 정책 강제 (Policy-based Access Control)
- **과제**: "최소 1회 이상 시도한 사용자만 해설을 볼 수 있다"는 학습 정책을 구현해야 함.
- **구현**:
  - `study_task_status` 테이블 조회.
  - `study_task_status_try_count < 1`인 경우, 해설 데이터 존재 여부와 관계없이 즉시 **403 Forbidden** 반환.
  - **404 Not Found**는 "권한은 있으나 해설 데이터가 DB에 없는 경우"에만 사용. 이로써 클라이언트는 "더 풀어야 하는지(403)" vs "해설이 없는 건지(404)"를 명확히 구분 가능.

### 2. 미디어 리소스 데이터 매핑 (Data Transformation)
- **과제**: DB 스키마는 MVP 단계라 `explain_media_url` (Nullable String) 컬럼 하나만 존재하지만, API 스펙은 확장성을 위해 `resources` (Array) 형태를 요구함.
- **해결**: Service 계층에서 타입 변환 수행.
  - `Some(url)` -> `vec![url]` (단일 요소를 가진 배열)
  - `None` -> `vec![]` (빈 배열)
  - 이를 통해 향후 DB가 1:N 테이블로 정규화되더라도 API 계약(`TaskExplainRes`)은 유지 가능.

### 3. 해설 조회 로깅 전략 (Logging Strategy)
- **정책**: 사용자가 해설을 열람한 행위(`explain`)도 학습 이력으로 `STUDY_TASK_LOG`에 남겨야 함.
- **결정**: **Fire-and-forget (비동기 처리)**.
  - 해설 조회는 트랜잭션이 필수적인 쓰기 작업이 아니므로, 로깅 실패가 해설 데이터 반환을 막아서는 안 됨.
  - `log_task_action` 호출 실패 시 `warn!` 로그만 남기고 200 OK 응답 진행.

### 4. 테이블 명명 규칙 준수 (Schema Consistency)
- **이슈**: 이전 작업에서 AI가 테이블명을 `study_explain` 등으로 잘못 유추하는 경향이 있었음.
- **조치**: `study_task_explain`이라는 정확한 테이블명과 `study_task_` prefix 규칙을 프롬프트 컨텍스트에 명시하여 쿼리 정확도 확보.

## 3. 총평 (Conclusion)
* **진행:** 초기 스키마 파악 단계에서 AI의 실수가 있었으나, 개발자의 정확한 가이드로 **테이블 네이밍 규칙(Consistency)**이 바로 잡힘.
* **결과:** 로직(403/404) 및 기능 테스트(cURL) 완벽 통과.