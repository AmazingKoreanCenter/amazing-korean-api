# 📝 Dev Notes: Phase 4-1 Implementation (GET /studies)

## 📋 개요
- **작업**: 스터디 목록 조회 API (`GET /studies`)
- **기간**: 2026.01.01
- **성격**: New Domain Init, Dynamic Query, Strict Error Handling (400 vs 422)

---

## 🛠️ 트러블슈팅 및 주요 기술적 의사결정 (Troubleshooting & Decisions)

### 1. HTTP 400 vs 422 에러 구분 (Strict Error Handling)
- **과제**: API 스펙상 `program` 파라미터가 유효하지 않은 값(Enum에 없음)일 때 **400 Bad Request**가 아닌 **422 Unprocessable Entity**를 반환해야 함.
- **문제**: Axum의 `Query<T>`에서 DTO 필드를 `Option<Enum>`으로 정의하면, 파싱 실패 시 프레임워크 레벨에서 즉시 **400** 에러를 리턴해버림 (커스텀 제어 불가).
- **해결**:
  - DTO에서는 `program: Option<String>`으로 받아 일단 파싱 성공(200 OK 진입) 시킴.
  - Service 계층에서 문자열을 Enum으로 변환(`from_str`) 시도.
  - 변환 실패 시 명시적으로 `AppError::Unprocessable` (422) 반환.
  - `page`, `per_page`의 숫자 형식이 틀린 경우엔 그대로 400 에러 허용.

### 2. DB 스키마 타입과 Rust 타입의 엄격한 매핑 (Type Compliance)
- **과제**: `AMK_SCHEMA_PATCHED.md`에 정의된 `updated_by_user_id`는 `BIGINT` 타입임.
- **원칙**: SQLx 매핑 시 **임의로 타입을 축소하지 않는다.**
- **해결**:
  - **Repository Layer**: DB와 통신하는 Entity 구조체에서는 `i64` (PostgreSQL BIGINT 대응)를 사용.
  - **Service Layer**: 비즈니스 로직 처리 시에도 `i64` 유지.
  - **잠재 위험 방지**: `i32`로 받을 경우 오버플로우나 매핑 에러(`MismatchedType`) 발생 가능성 원천 차단.

### 3. API 응답의 프론트엔드 호환성 (JSON Serialization)
- **과제**: DB에서는 `i64`를 쓰지만, 프론트엔드(JS/TS)는 `number` 타입의 안전한 처리 범위와 관습상 `ID`나 `Count` 필드에 대해 `i32`/`u32`를 선호함.
- **해결**: **Response DTO 변환 시점**에 타입 캐스팅 수행.
  - `DB(i64)` -> `Service` -> `Response DTO(u32/i32)`
  - 예: `total_count: i64` (DB) -> `total_count: u32` (JSON).
  - 단, 데이터 손실 가능성이 있는 경우(매우 큰 수)에는 `try_from`을 사용하여 안전하게 변환하거나 에러 로그를 남김(현재 도메인 규모상 `u32` 범위 내 안전).

### 4. 동적 쿼리 빌더 활용 (Dynamic Query with SQLx)
- **과제**: `program` 필터는 선택적(`Option`)이며, `sort` 조건에 따라 정렬 기준이 동적으로 변해야 함.
- **해결**: `sqlx::QueryBuilder` 패턴 사용.
  - 기본 쿼리: `SELECT ... FROM STUDY WHERE study_state = 'open'`
  - 조건 추가: `if let Some(p) = program { builder.push(" AND study_program = "); builder.push_bind(p); }`
  - **주의**: Enum 타입을 바인딩할 때 PostgreSQL `CAST`(`::study_program_enum`) 필요 여부 확인.

### 5. 정렬(Sort) 안전성 확보 (SQL Injection Prevention)
- **위험**: 클라이언트가 보낸 `sort` 문자열을 검증 없이 SQL `ORDER BY` 절에 삽입하면 Injection 공격에 취약함.
- **해결**: **Allowlist(화이트리스트) 방식** 적용.
  - 입력값 매칭: `req.sort.as_deref()`
  - 허용 패턴:
    - `"latest"` -> `ORDER BY study_created_at DESC`
    - `"oldest"` -> `ORDER BY study_created_at ASC`
    - `"alphabetical"` -> `ORDER BY study_title ASC`
  - 매칭되지 않는 값이나 기본값인 경우 안전하게 `latest` 로직 적용.

### 6. 공통 Enum 활용
- **원칙**: `study_program` 등의 Enum은 문자열 하드코딩을 지양함.
- **적용**:
  - `src/types.rs`에 정의된 공통 타입을 `use` 하거나,
  - 해당 모듈 `dto.rs`에 `strum::EnumString`을 derive한 Enum을 정의하여 Type-Safe하게 파싱 및 관리.

---

## 🔑 확립된 핵심 개발 패턴 (Key Patterns)

### 1. Domain Module Structure
- **패턴**: 새로운 도메인(`study`) 추가 시 `mod`, `dto`, `repo`, `service`, `handler`, `router`의 6개 파일 세트를 표준으로 생성하고, `src/api/mod.rs`와 메인 라우터에 등록하는 절차 확립.

### 2. Validation with 'validator' crate
- **패턴**: `per_page`와 같은 숫자형 파라미터의 범위(`range(min=1, max=100)`) 검증을 위해 `validator` 매크로 사용. 이를 통해 비즈니스 로직 진입 전 깔끔하게 입력값 방어.

---

## ✅ 결론
- **구현 완료**: 스터디 목록 조회, 프로그램 필터링, 정렬, 페이지네이션 정상 동작.
- **테스트 통과**: 
  - 정상 케이스(200) 및 데이터 검증 완료.
  - 에러 케이스(잘못된 Enum -> 422, 범위 초과 -> 422) 스펙 준수 확인.
- **다음 단계**: 목록에서 선택한 스터디의 세부 문제 목록을 조회하는 **Phase 4-2 (스터디 문제 목록 조회)** 구현 진입.