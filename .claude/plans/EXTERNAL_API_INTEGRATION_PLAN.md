# 외부 API 연동 구현 계획

> 작성일: 2026-02-02
> 진행 순서: Google OAuth → Stripe 결제 → IP Geolocation

---

## Phase A: Google OAuth 소셜 로그인

### A-1. 사전 준비 (사용자)

| 항목 | 작업 |
|------|------|
| Google Cloud Console | 프로젝트 생성 |
| OAuth 2.0 Client ID | "웹 애플리케이션" 타입 생성 |
| Authorized redirect URI | `https://api.amazingkorean.net/auth/google/callback` |
| 환경변수 | `GOOGLE_CLIENT_ID`, `GOOGLE_CLIENT_SECRET` |

### A-2. 백엔드 구현

#### 파일 구조
```
src/api/auth/
├── handler.rs      # + google_login, google_callback 추가
├── service.rs      # + GoogleAuthService 추가
├── dto.rs          # + GoogleAuthReq, GoogleUserInfo 추가
└── google.rs       # (신규) Google OAuth 클라이언트
```

#### 엔드포인트
| Method | Path | 설명 |
|--------|------|------|
| GET | `/auth/google` | Google 로그인 페이지로 리다이렉트 |
| GET | `/auth/google/callback` | OAuth 콜백 처리, JWT 발급 |

#### 구현 흐름
```
1. 프론트: "Google 로그인" 버튼 클릭
   ↓
2. GET /auth/google → Google OAuth 페이지로 302 리다이렉트
   ↓
3. 사용자: Google 계정 선택 & 동의
   ↓
4. Google → /auth/google/callback?code=xxx 로 리다이렉트
   ↓
5. 백엔드: code로 access_token 교환
   ↓
6. 백엔드: access_token으로 사용자 정보 조회
   ↓
7. 백엔드: users 테이블에서 google_id로 조회/생성
   ↓
8. 백엔드: JWT 발급, 프론트로 리다이렉트 (쿠키 설정)
```

#### DB 변경
```sql
-- users 테이블에 google_id 컬럼 추가 (이미 user_auth enum에 'google' 있음)
ALTER TABLE users ADD COLUMN google_id VARCHAR(255) UNIQUE;
CREATE INDEX idx_users_google_id ON users(google_id);
```

#### 의존성 추가 (Cargo.toml)
```toml
oauth2 = "4.4"
```

### A-3. 프론트엔드 구현

#### 파일
```
frontend/src/category/auth/
├── page/login_page.tsx    # + Google 로그인 버튼 추가
└── components/
    └── google_login_button.tsx  # (신규)
```

#### UI
- 로그인 페이지에 "Google로 로그인" 버튼 추가
- 클릭 시 `window.location.href = '/api/auth/google'`

### A-4. 예상 소요 시간
- 백엔드: 3-4시간
- 프론트엔드: 1시간
- 테스트: 1시간

---

## Phase B: Stripe 결제 시스템

### B-1. 사전 준비 (사용자)

| 항목 | 작업 |
|------|------|
| Stripe 계정 | dashboard.stripe.com 가입 |
| API Keys | Secret Key, Publishable Key 복사 |
| Webhook | Endpoint URL 등록, Webhook Secret 복사 |
| Products | 수강권 상품 생성 (Dashboard) |
| 환경변수 | `STRIPE_SECRET_KEY`, `STRIPE_PUBLISHABLE_KEY`, `STRIPE_WEBHOOK_SECRET` |

### B-2. 백엔드 구현

#### 파일 구조
```
src/api/payment/
├── mod.rs
├── handler.rs      # checkout, webhook, subscription 관리
├── service.rs      # Stripe API 호출
├── dto.rs          # CheckoutReq, WebhookEvent 등
├── router.rs
└── stripe.rs       # Stripe 클라이언트 래퍼
```

#### 엔드포인트
| Method | Path | 설명 |
|--------|------|------|
| POST | `/payment/checkout` | Stripe Checkout Session 생성 |
| POST | `/payment/webhook` | Stripe Webhook 수신 |
| GET | `/payment/subscriptions` | 내 구독 목록 조회 |
| POST | `/payment/cancel` | 구독 취소 |

#### 구현 흐름 (Checkout)
```
1. 프론트: "구매하기" 버튼 클릭
   ↓
2. POST /payment/checkout { price_id, course_id }
   ↓
3. 백엔드: Stripe Checkout Session 생성
   ↓
4. 백엔드: checkout_url 반환
   ↓
5. 프론트: window.location.href = checkout_url
   ↓
6. 사용자: Stripe 결제 페이지에서 결제
   ↓
7. Stripe → /payment/webhook (checkout.session.completed)
   ↓
8. 백엔드: user_course 테이블에 수강권 추가
```

#### DB 변경
```sql
-- 결제 기록 테이블
CREATE TABLE payment_log (
    payment_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(user_id),
    course_id INT REFERENCES course(course_id),
    stripe_session_id VARCHAR(255) UNIQUE,
    stripe_payment_intent_id VARCHAR(255),
    amount INT NOT NULL,
    currency VARCHAR(3) NOT NULL DEFAULT 'KRW',
    status VARCHAR(50) NOT NULL, -- pending, completed, failed, refunded
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_payment_log_user ON payment_log(user_id);
CREATE INDEX idx_payment_log_stripe_session ON payment_log(stripe_session_id);
```

#### 의존성 추가 (Cargo.toml)
```toml
stripe-rust = "0.31"  # 또는 async-stripe
```

### B-3. 프론트엔드 구현

#### 파일
```
frontend/src/category/payment/
├── page/checkout_page.tsx      # 결제 페이지
├── page/success_page.tsx       # 결제 완료
├── page/cancel_page.tsx        # 결제 취소
└── components/
    └── price_card.tsx          # 가격 카드 컴포넌트
```

### B-4. Course 도메인 연계

```
user_course 테이블 활용:
- 결제 완료 시 user_course INSERT
- lesson_access = 'paid' 콘텐츠 접근 시 user_course 확인
- course_valid_days 기반 만료 체크
```

### B-5. 예상 소요 시간
- 백엔드: 1일
- 프론트엔드: 반나절
- 테스트: 반나절

---

## Phase C: IP Geolocation

### C-1. 서비스 선택

| 서비스 | 장점 | 단점 | 선택 |
|--------|------|------|:----:|
| ip-api.com | 무료, 간단 | 상업용 금지, 속도제한 | 개발용 |
| ipinfo.io | 50k/월 무료 | API Key 필요 | **추천** |
| MaxMind | 로컬 DB, 빠름 | DB 다운로드/업데이트 필요 | 대량 처리 |

### C-2. 백엔드 구현 (ipinfo.io 기준)

#### 파일 구조
```
src/services/
└── geoip.rs        # (신규) IP Geolocation 서비스

src/api/auth/
├── service.rs      # login() 함수에서 geoip 호출
└── repo.rs         # insert_login_log()에 실제 값 전달
```

#### 구현 내용
```rust
// src/services/geoip.rs
pub struct GeoIpInfo {
    pub country: String,      // "KR"
    pub asn: i32,             // AS number
    pub org: String,          // ISP/Organization
    pub city: Option<String>,
    pub region: Option<String>,
}

pub async fn lookup_ip(ip: &str) -> Option<GeoIpInfo> {
    // ipinfo.io API 호출
    // 캐싱 고려 (Redis)
}
```

#### 기존 코드 수정
```rust
// src/api/auth/repo.rs - insert_login_log()
// 기존: 'ZZ', 0, 'Unknown' (placeholder)
// 변경: 실제 geoip 정보 전달
```

#### 환경변수
```
IPINFO_TOKEN=your_token_here
```

### C-3. 캐싱 전략
```
Redis 캐싱 (선택):
- Key: geoip:{ip}
- TTL: 24시간
- 동일 IP 반복 조회 방지
```

### C-4. 예상 소요 시간
- 백엔드: 2시간
- 테스트: 30분

---

## 전체 일정 요약

| Phase | 작업 | 예상 소요 |
|-------|------|----------|
| **A** | Google OAuth | 반나절 |
| **B** | Stripe 결제 | 1.5일 |
| **C** | IP Geolocation | 2-3시간 |
| | **총합** | **약 2.5일** |

---

## 환경변수 총정리

```bash
# .env.example 추가 항목

# Google OAuth
GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=
GOOGLE_REDIRECT_URI=https://api.amazingkorean.net/auth/google/callback

# Stripe
STRIPE_SECRET_KEY=
STRIPE_PUBLISHABLE_KEY=
STRIPE_WEBHOOK_SECRET=

# IP Geolocation
IPINFO_TOKEN=
```

---

## 체크리스트

### Phase A 시작 전
- [ ] Google Cloud Console 프로젝트 생성
- [ ] OAuth 2.0 Client ID 발급
- [ ] Redirect URI 설정
- [ ] 환경변수 준비

### Phase B 시작 전
- [ ] Stripe 계정 생성
- [ ] API Keys 복사
- [ ] 테스트 상품 생성
- [ ] Webhook URL 등록

### Phase C 시작 전
- [ ] ipinfo.io 계정 생성 (선택)
- [ ] API Token 발급
